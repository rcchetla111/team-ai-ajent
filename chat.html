<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent 365 - AI Meeting Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script
      src="https://unpkg.com/adaptivecards/dist/adaptivecards.min.js"
      crossorigin="anonymous"
    ></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      .adaptive-card {
        border-radius: 0.5rem;
        border: 1px solid #e5e7eb;
      }
      .chat-container::-webkit-scrollbar {
        width: 8px;
      }
      .chat-container::-webkit-scrollbar-track {
        background: #f1f5f9;
      }
      .chat-container::-webkit-scrollbar-thumb {
        background: #94a3b8;
        border-radius: 4px;
      }
      .typing-indicator {
        animation: pulse 1.5s ease-in-out infinite;
      }
      .auto-insights-status {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        margin-left: 10px;
        display: none;
      }
      .auto-insights-active {
        display: inline-block;
        animation: pulse 2s infinite;
      }
      .meeting-card {
        background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        border: 2px solid #0ea5e9;
        border-radius: 12px;
        padding: 16px;
        margin: 8px 0;
      }
      .action-button {
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        color: white;
        padding: 8px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        margin: 4px;
        transition: all 0.3s ease;
      }
      .action-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }
      .status-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
      }
      .status-scheduled {
        background: #dbeafe;
        color: #1e40af;
      }
      .status-in-progress {
        background: #dcfce7;
        color: #166534;
      }
      .status-completed {
        background: #f3e8ff;
        color: #7c3aed;
      }
      .status-cancelled {
        background: #fee2e2;
        color: #dc2626;
      }
    </style>
  </head>
  <body
    class="bg-slate-100 flex flex-col items-center justify-center h-screen p-4"
  >
    <div
      class="w-full max-w-6xl mx-auto flex flex-col h-full bg-white rounded-2xl shadow-2xl"
    >
      <!-- Enhanced Header with Auto-Insights Status -->
      <div
        class="p-4 border-b border-slate-200 flex justify-between items-center"
      >
        <div class="flex items-center space-x-3">
          <div
            class="p-2 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6 text-white"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2 2v10a2 2 0 002 2z"
              />
            </svg>
          </div>
          <div>
            <h1 class="text-lg font-bold text-slate-800">Agent 365</h1>
            <p class="text-sm text-slate-500">
              AI Meeting Assistant with Teams Integration
            </p>
          </div>
          <!-- Auto-Insights Status Indicator -->
          <div class="auto-insights-status" id="auto-insights-status">
            ü§ñ Auto-Insights Active
          </div>
        </div>
      </div>

      <!-- Chat Messages -->
      <div
        id="chat-container"
        class="flex-1 p-6 overflow-y-auto chat-container"
      ></div>

      <!-- Enhanced Message Input -->
      <div class="p-4 border-t border-slate-200 bg-slate-50">
        <div class="flex flex-wrap gap-2 mb-3" id="quick-actions">
          <button
            onclick="sendQuickMessage('Create a meeting tomorrow at 2pm with John Smith about project review')"
            class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-xs hover:bg-blue-200"
          >
            üóìÔ∏è Schedule Meeting
          </button>
          <button
            onclick="sendQuickMessage('Show my recent meetings')"
            class="px-3 py-1 bg-green-100 text-green-700 rounded-full text-xs hover:bg-green-200"
          >
            üìã My Meetings
          </button>
          <button
            onclick="sendQuickMessage('Find team members named John')"
            class="px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs hover:bg-purple-200"
          >
            üë• Find People
          </button>
          <button
            onclick="sendQuickMessage('Send message to Sarah about project update')"
            class="px-3 py-1 bg-orange-100 text-orange-700 rounded-full text-xs hover:bg-orange-200"
          >
            üí¨ Send Message
          </button>
          <button
            onclick="sendQuickMessage('Join AI agent to my latest meeting')"
            class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded-full text-xs hover:bg-indigo-200"
          >
            ü§ñ Join Agent
          </button>
          <button
            onclick="sendQuickMessage('Get summary of my last meeting')"
            class="px-3 py-1 bg-pink-100 text-pink-700 rounded-full text-xs hover:bg-pink-200"
          >
            üìä Meeting Summary
          </button>
        </div>
        <form id="chat-form" class="flex items-center space-x-3">
          <input
            type="text"
            id="message-input"
            class="flex-1 block w-full px-4 py-3 bg-white border border-slate-300 rounded-xl text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:bg-slate-100"
            placeholder="Schedule a meeting, find people, or ask about your calendar..."
            autocomplete="off"
            disabled
          />
          <button
            type="submit"
            id="send-button"
            class="p-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-xl hover:from-blue-600 hover:to-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-slate-300"
            disabled
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"
              />
            </svg>
          </button>
        </form>
      </div>
    </div>

    <script>
      const ui = {
        chatContainer: document.getElementById("chat-container"),
        chatForm: document.getElementById("chat-form"),
        messageInput: document.getElementById("message-input"),
        sendButton: document.getElementById("send-button"),
        autoInsightsStatus: document.getElementById("auto-insights-status"),
      };

      const API_BASE_URL = "http://localhost:5000/api";
      const GEMINI_API_KEY = "AIzaSyBnsIjTRbrHAwKC5ko5K0dvxjp3Cwj5GoQ";
      const GEMINI_MODEL = "gemini-2.0-flash";

      // Enhanced session management
      let sessionId = Date.now();
      let conversationHistory = [];
      let lastCreatedMeeting = null;
      let autoInsightsActive = false;
      let responseVarietyTracker = new Set();
      let userMeetings = [];

      // ====================================================================
      // --- COMPREHENSIVE AGENT TOOLS ---
      // ====================================================================

      const agentTools = [
        {
          name: "create_meeting",
          description:
            "Creates a new Teams meeting with auto-insights and attendee resolution",
          parameters: {
            type: "object",
            properties: {
              subject: { type: "string", description: "Meeting title/subject" },
              description: {
                type: "string",
                description: "Meeting description",
              },
              date: {
                type: "string",
                description:
                  "Date like 'today', 'tomorrow', 'January 15', '2025-01-15'",
              },
              time: {
                type: "string",
                description: "Time like '2pm', '14:30', '3:00 PM'",
              },
              attendees: {
                type: "array",
                items: { type: "string" },
                description: "Names or emails of attendees",
              },
              duration: {
                type: "number",
                description: "Meeting duration in minutes, default 30",
              },
              enableAutoInsights: {
                type: "boolean",
                description: "Enable auto-insights, default true",
              },
              enableChatCapture: {
                type: "boolean",
                description: "Enable chat monitoring, default true",
              },
            },
            required: ["subject", "date", "time"],
          },
        },
        {
          name: "get_meetings",
          description: "Lists user's meetings with filters and details",
          parameters: {
            type: "object",
            properties: {
              status: {
                type: "string",
                enum: ["scheduled", "in_progress", "completed", "cancelled"],
              },
              limit: {
                type: "number",
                description: "Number of meetings to show, default 10",
              },
              detailed: {
                type: "boolean",
                description: "Show detailed meeting info, default false",
              },
            },
          },
        },
        {
          name: "join_meeting_agent",
          description:
            "Join AI agent to a specific meeting for live monitoring",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "leave_meeting_agent",
          description: "Remove AI agent from meeting and generate summary",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "cancel_meeting",
          description: "Cancel a scheduled meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_details",
          description: "Get detailed information about a specific meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_summary",
          description: "Generate or retrieve meeting summary with AI insights",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
              regenerate: {
                type: "boolean",
                description: "Force regenerate summary, default false",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_analysis",
          description: "Get detailed chat analysis and insights for a meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "find_people",
          description: "Search for team members by name or role",
          parameters: {
            type: "object",
            properties: {
              searchTerm: {
                type: "string",
                description: "Name or role to search for",
              },
              limit: {
                type: "number",
                description: "Max results to return, default 10",
              },
            },
            required: ["searchTerm"],
          },
        },
        {
          name: "get_team_members",
          description: "List all team members in the organization",
          parameters: {
            type: "object",
            properties: {
              limit: {
                type: "number",
                description: "Max members to show, default 20",
              },
              includeDetails: {
                type: "boolean",
                description: "Include job titles and departments",
              },
            },
          },
        },
        {
          name: "send_message",
          description: "Send a message to a team member",
          parameters: {
            type: "object",
            properties: {
              recipient: {
                type: "string",
                description: "Name or email of recipient",
              },
              message: {
                type: "string",
                description: "Message content to send",
              },
            },
            required: ["recipient", "message"],
          },
        },
        {
          name: "resolve_users",
          description: "Resolve user names to emails using Teams directory",
          parameters: {
            type: "object",
            properties: {
              names: {
                type: "array",
                items: { type: "string" },
                description: "Array of names to resolve",
              },
            },
            required: ["names"],
          },
        },
        {
          name: "suggest_meeting_times",
          description:
            "Find optimal meeting times based on attendee availability",
          parameters: {
            type: "object",
            properties: {
              attendees: {
                type: "array",
                items: { type: "string" },
                description: "Attendee emails",
              },
              duration: {
                type: "number",
                description: "Meeting duration in minutes, default 30",
              },
            },
            required: ["attendees"],
          },
        },
        {
          name: "answer_general_question",
          description:
            "Handle general questions, greetings, and provide information",
          parameters: {
            type: "object",
            properties: {
              responseText: { type: "string", description: "Response to user" },
              responseType: {
                type: "string",
                description: "Type of response for variety tracking",
              },
              includeCapabilities: {
                type: "boolean",
                description: "Include capability overview",
              },
            },
            required: ["responseText"],
          },
        },
        {
          name: "create_channel",
          description: "Create a new Teams channel in an existing team",
          parameters: {
            type: "object",
            properties: {
              teamName: {
                type: "string",
                description: "Name of the team to create channel in",
              },
              channelName: {
                type: "string",
                description: "Name of the new channel",
              },
              description: {
                type: "string",
                description: "Channel description",
              },
              membershipType: {
                type: "string",
                enum: ["standard", "private"],
                description: "Channel type - standard (public) or private",
              },
            },
            required: ["teamName", "channelName"],
          },
        },
        {
          name: "list_teams",
          description: "List available teams where you can create channels",
          parameters: {
            type: "object",
            properties: {},
          },
        },
        {
          name: "list_channels",
          description: "List channels in a specific team",
          parameters: {
            type: "object",
            properties: {
              teamName: {
                type: "string",
                description: "Name of the team to list channels for",
              },
            },
            required: ["teamName"],
          },
        },
      ];

      // ====================================================================
      // --- ENHANCED AGENT PROMPT ---
      // ====================================================================

 function getAgentPrompt(history, message) {
  const historyString = history
    .slice(-6)
    .map((turn, index) => `${turn.role}: ${turn.message}`)
    .join("\n");
  const currentDate = new Date().toLocaleDateString();
  const currentTime = new Date().toLocaleTimeString();

  return `You are Agent 365, an advanced AI meeting assistant with full Microsoft Teams integration including channel management.

**Current Context:**
- Date: ${currentDate}
- Time: ${currentTime}
- Session: ${sessionId}

**Recent Conversation:**
${historyString}

**User Request:** "${message}"

**SEARCH TERM EXTRACTION RULES:**
- "Find team members named John" ‚Üí searchTerm: "John"
- "Search for people called Sarah" ‚Üí searchTerm: "Sarah"
- "Find John Smith" ‚Üí searchTerm: "John Smith"
- "Look for engineers" ‚Üí searchTerm: "engineers"
- "Find team members" ‚Üí searchTerm: "team" (or use get_team_members instead)

**MEETING QUERY RULES:**
- "Show my meetings" ‚Üí get_meetings with no filters
- "My recent meetings" ‚Üí get_meetings with detailed: true
- "Show scheduled meetings" ‚Üí get_meetings with status: "scheduled"

**CHANNEL CREATION RULES:**
- "Create a channel called [name] in [team]" ‚Üí create_channel
- "Make a [private/public] channel for [purpose]" ‚Üí create_channel
- "Create channel [name] in [team] team" ‚Üí create_channel
- "Show me available teams" ‚Üí list_teams
- "List teams" ‚Üí list_teams
- "What teams can I create channels in" ‚Üí list_teams
- "List channels in [team]" ‚Üí list_channels
- "Show channels in [team] team" ‚Üí list_channels

**CHANNEL EXTRACTION EXAMPLES:**
- "Create a channel called 'Sprint Planning' in Engineering team" ‚Üí teamName: "Engineering", channelName: "Sprint Planning"
- "Make a private channel for HR discussions in Admin team" ‚Üí teamName: "Admin", channelName: "HR discussions", membershipType: "private"
- "Create public channel named 'General Discussion' in Product team" ‚Üí teamName: "Product", channelName: "General Discussion", membershipType: "standard"
- "Create channel 'Bug Reports' in Development" ‚Üí teamName: "Development", channelName: "Bug Reports"

**RESPONSE EXAMPLES:**

User: "Find team members named John"
Response: {
  "tool_name": "find_people",
  "parameters": {
    "searchTerm": "John",
    "limit": 10
  }
}

User: "Show my recent meetings"
Response: {
  "tool_name": "get_meetings", 
  "parameters": {
    "limit": 10,
    "detailed": true
  }
}

User: "Find team members"
Response: {
  "tool_name": "get_team_members",
  "parameters": {
    "limit": 20,
    "includeDetails": true
  }
}

User: "Create a channel called 'Sprint Planning' in Engineering team"
Response: {
  "tool_name": "create_channel",
  "parameters": {
    "teamName": "Engineering",
    "channelName": "Sprint Planning",
    "description": "Channel for sprint planning discussions",
    "membershipType": "standard"
  }
}

User: "Make a private channel for HR discussions"
Response: {
  "tool_name": "create_channel",
  "parameters": {
    "teamName": "General",
    "channelName": "HR discussions", 
    "description": "Private channel for HR team discussions",
    "membershipType": "private"
  }
}

User: "Show me available teams"
Response: {
  "tool_name": "list_teams",
  "parameters": {}
}

User: "List channels in Product team"
Response: {
  "tool_name": "list_channels",
  "parameters": {
    "teamName": "Product"
  }
}

**CRITICAL RULES:**
1. ALWAYS extract the actual search term from user messages
2. NEVER use "undefined" or empty values
3. Provide sensible defaults for all parameters
4. Use exact names when mentioned by the user
5. For channels: Extract team name and channel name separately
6. Default to "standard" membership for channels unless "private" is specified
7. Generate helpful descriptions for channels when not provided

**Available Tools:**
- create_meeting: Schedule meetings
- get_meetings: List user's meetings
- find_people: Search for specific team members by name
- get_team_members: List all team members
- join_meeting_agent: Join AI agent to meetings
- leave_meeting_agent: Leave meetings
- cancel_meeting: Cancel meetings
- get_meeting_details: Get meeting information
- get_meeting_summary: Generate meeting summaries
- get_meeting_analysis: Analyze meetings
- send_message: Send messages
- resolve_users: Resolve names to emails
- suggest_meeting_times: Find optimal times
- create_channel: Create new Teams channels
- list_teams: Show available teams for channel creation
- list_channels: Show channels in a specific team
- answer_general_question: Handle general queries

**CHANNEL CREATION RULES:**
- "Create a channel called [name] in [team]" ‚Üí create_channel
- "Make a [private/public] channel for [purpose] in [team]" ‚Üí create_channel
- "Create channel [name] in [team] team" ‚Üí create_channel
- "Make a [private/public] channel for [purpose]" ‚Üí create_channel (use default team)
- "Create [name] channel" ‚Üí create_channel (use default team)
- "Show me available teams" ‚Üí list_teams
- "List teams" ‚Üí list_teams
- "What teams can I create channels in" ‚Üí list_teams
- "List channels in [team]" ‚Üí list_channels
- "Show channels in [team] team" ‚Üí list_channels

**CHANNEL EXTRACTION EXAMPLES:**
- "Create a channel called 'Sprint Planning' in Engineering team" ‚Üí teamName: "Engineering", channelName: "Sprint Planning"
- "Make a private channel for HR discussions in Admin team" ‚Üí teamName: "Admin", channelName: "HR discussions", membershipType: "private"
- "Make a private channel for HR discussions" ‚Üí teamName: "General", channelName: "HR discussions", membershipType: "private"
- "Create public channel named 'General Discussion' in Product team" ‚Üí teamName: "Product", channelName: "General Discussion", membershipType: "standard"
- "Create channel 'Bug Reports' in Development" ‚Üí teamName: "Development", channelName: "Bug Reports"
- "Make a private channel for confidential stuff" ‚Üí teamName: "General", channelName: "confidential stuff", membershipType: "private"

**IMPORTANT:**
- Extract search terms EXACTLY as mentioned by user
- Always provide required parameters
- Use appropriate tools for each request type
- For channels, separate team name from channel name clearly
- Respond ONLY with valid JSON

Analyze the user request and respond with the appropriate tool:`;
}

      // ====================================================================
      // --- AI RESPONSE GENERATION ---
      // ====================================================================

      async function getAgentAction(message) {
        const prompt = getAgentPrompt(conversationHistory, message);
        console.log("ü§ñ Agent Prompt:", prompt);

        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        try {
          const response = await fetch(API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{ parts: [{ text: prompt }] }],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 1000,
                topP: 0.9,
                topK: 40,
              },
            }),
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Gemini API error: ${errorData.error.message}`);
          }

          const data = await response.json();
          const rawText = data.candidates[0].content.parts[0].text;
          console.log("ü§ñ Raw AI Response:", rawText);

          // IMPROVED JSON PARSING - Fix the malformed JSON issue
          let jsonString = rawText.replace(/```json|```/g, "").trim();

          // Try to find JSON within the response if it's wrapped in other text
          const jsonMatch = jsonString.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            jsonString = jsonMatch[0];
          }

          let action;
          try {
            action = JSON.parse(jsonString);
          } catch (parseError) {
            console.error("JSON Parse Error:", parseError);
            console.error("Failed JSON String:", jsonString);

            // Fallback: create a general response action
            return {
              tool_name: "answer_general_question",
              parameters: {
                responseText:
                  "I understand you'd like help with that. Let me assist you with your meeting and collaboration needs.",
                responseType: "fallback",
              },
            };
          }

          console.log("ü§ñ Parsed Action:", action);
          return action;
        } catch (error) {
          console.error("AI Action Error:", error);
          return {
            tool_name: "answer_general_question",
            parameters: {
              responseText: `I'm having trouble processing that request. Please try rephrasing your request or use one of the quick action buttons.`,
              responseType: "error",
            },
          };
        }
      }

    async function handleCreateChannel(params) {
  try {
    console.log("üÜï Creating channel with params:", params);
    
    // Provide better defaults and validation
    if (!params.channelName) {
      throw new Error("Channel name is required");
    }
    
    // Default team name if not provided
    if (!params.teamName) {
      params.teamName = "General";
      console.log("‚ö†Ô∏è No team specified, defaulting to 'General' team");
    }
    
    // Default membership type
    if (!params.membershipType) {
      params.membershipType = "standard";
    }
    
    console.log("üìã Final channel params:", params);

    // First, get available teams to find the team ID
    const teamsResponse = await fetch(`${API_BASE_URL}/channels/teams`);
    
    if (!teamsResponse.ok) {
      // If backend isn't implemented, show helpful message
      const msg = `üöß **Channel Creation Ready!**\n\n` +
        `üìÅ **Requested Channel:** ${params.channelName}\n` +
        `üè¢ **Target Team:** ${params.teamName}\n` +
        `üìù **Type:** ${params.membershipType}\n` +
        `üìñ **Description:** ${params.description || 'Channel for team collaboration'}\n\n` +
        `‚ö†Ô∏è **Backend Setup Needed:**\n` +
        `The frontend is ready, but you need to implement:\n` +
        `‚Ä¢ Channel creation API endpoints (/channels/teams, /channels/create)\n` +
        `‚Ä¢ Teams service channel methods\n` +
        `‚Ä¢ Microsoft Graph Channel.Create permissions\n\n` +
        `üéØ **Good news:** Your AI prompt and frontend are working perfectly!\n` +
        `The parameters were extracted correctly: team="${params.teamName}", channel="${params.channelName}", type="${params.membershipType}"`;

      addMessage(msg, "bot");
      return msg;
    }
    
    const teamsData = await teamsResponse.json();

    // Find team by name (case-insensitive)
    const team = teamsData.teams.find((t) =>
      t.displayName.toLowerCase().includes(params.teamName.toLowerCase())
    );

    if (!team) {
      throw new Error(
        `Team "${params.teamName}" not found. Available teams: ${teamsData.teams
          .map((t) => t.displayName)
          .join(", ")}`
      );
    }

    // Create the channel
    const response = await fetch(`${API_BASE_URL}/channels/create`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        teamId: team.id,
        displayName: params.channelName,
        description:
          params.description ||
          `${params.channelName} - Created via AI Agent`,
        membershipType: params.membershipType,
      }),
    });

    const data = await response.json();
    if (!response.ok) {
      throw new Error(
        data.details || data.error || "Failed to create channel"
      );
    }

    const msg =
      `‚úÖ **Channel Created Successfully!**\n\n` +
      `üìÅ **Channel:** ${data.channel.displayName}\n` +
      `üè¢ **Team:** ${team.displayName}\n` +
      `üìù **Type:** ${data.channel.membershipType}\n` +
      `üîó **Link:** ${data.channel.webUrl || "Available in Teams"}\n\n` +
      `The channel is now ready for your team to use!`;

    addMessage(msg, "bot");
    return msg;
  } catch (error) {
    console.error("‚ùå Channel creation error:", error);
    const msg = `‚ùå Failed to create channel: ${error.message}`;
    addMessage(msg, "bot");
    return msg;
  }
}

      async function handleListTeams(params) {
        try {
          const response = await fetch(`${API_BASE_URL}/channels/teams`);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get teams");
          }

          if (data.teams.length === 0) {
            const msg = "üè¢ No teams found where you can create channels.";
            addMessage(msg, "bot");
            return msg;
          }

          let msg = `üè¢ **Available Teams for Channel Creation:**\n\n`;
          data.teams.forEach((team, index) => {
            msg += `${index + 1}. **${team.displayName}**\n`;
            if (team.description) msg += `   üìù ${team.description}\n`;
            msg += `\n`;
          });

          msg += `üí° Use "Create channel [name] in [team]" to create a new channel.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to get teams: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      // ====================================================================
      // --- MESSAGE HANDLING ---
      // ====================================================================

      async function handleUserMessage(message) {
        addMessage(message, "user");
        conversationHistory.push({
          role: "user",
          message: message,
          timestamp: Date.now(),
        });

        showLoading(true);

        try {
          const action = await getAgentAction(message);
          console.log("ü§ñ AI Action received:", action);

          if (!action || !action.tool_name) {
            addMessage(
              "I'm not sure how to help with that. Could you please rephrase your request?",
              "bot"
            );
            showLoading(false);
            return;
          }

          // Validate action has required parameters
          if (!action.parameters) {
            action.parameters = {};
          }

          let agentResponseText = "";
          try {
            switch (action.tool_name) {
              case "create_meeting":
                agentResponseText = await handleCreateMeeting(
                  action.parameters
                );
                break;
              case "get_meetings":
                agentResponseText = await handleGetMeetings(action.parameters);
                break;
              case "find_people":
                agentResponseText = await handleFindPeople(action.parameters);
                break;
              case "get_team_members":
                agentResponseText = await handleGetTeamMembers(
                  action.parameters
                );
                break;
              case "join_meeting_agent":
                agentResponseText = await handleJoinMeetingAgent(
                  action.parameters
                );
                break;
              case "leave_meeting_agent":
                agentResponseText = await handleLeaveMeetingAgent(
                  action.parameters
                );
                break;
              case "cancel_meeting":
                agentResponseText = await handleCancelMeeting(
                  action.parameters
                );
                break;
              case "get_meeting_details":
                agentResponseText = await handleGetMeetingDetails(
                  action.parameters
                );
                break;
              case "get_meeting_summary":
                agentResponseText = await handleGetMeetingSummary(
                  action.parameters
                );
                break;
              case "get_meeting_analysis":
                agentResponseText = await handleGetMeetingAnalysis(
                  action.parameters
                );
                break;
              case "send_message":
                agentResponseText = await handleSendMessage(action.parameters);
                break;
              case "resolve_users":
                agentResponseText = await handleResolveUsers(action.parameters);
                break;
              case "suggest_meeting_times":
                agentResponseText = await handleSuggestMeetingTimes(
                  action.parameters
                );
                break;
              case "answer_general_question":
                agentResponseText =
                  action.parameters.responseText ||
                  "Hello! How can I help you today?";
                if (action.parameters.includeCapabilities) {
                  agentResponseText += "\n\n" + getCapabilitiesOverview();
                }
                addMessage(agentResponseText, "bot");
                break;
              case "create_channel":
                agentResponseText = await handleCreateChannel(
                  action.parameters
                );
                break;
              case "list_teams":
                agentResponseText = await handleListTeams(action.parameters);
                break;
              case "list_channels":
                agentResponseText = await handleListChannels(action.parameters);
                break;
              default:
                agentResponseText = `I understand you want to ${action.tool_name}, but I'm not sure how to handle that yet. Please try a different request.`;
                addMessage(agentResponseText, "bot");
            }
          } catch (error) {
            console.error("Tool execution error:", error);
            agentResponseText = `Sorry, I encountered an error while processing your request: ${error.message}`;
            addMessage(agentResponseText, "bot");
          }

          conversationHistory.push({
            role: "agent",
            message: agentResponseText,
            timestamp: Date.now(),
            tool_used: action.tool_name,
          });

          if (conversationHistory.length > 10) {
            conversationHistory = conversationHistory.slice(-10);
          }
        } catch (error) {
          console.error("Message handling error:", error);
          addMessage(
            "I'm having trouble understanding that request. Please try rephrasing it or use one of the quick action buttons.",
            "bot"
          );
        }

        showLoading(false);
      }

      async function handleListChannels(params) {
  try {
    const teamName = params.teamName || "Unknown Team";
    
    // For now, since backend isn't fully implemented, show simulated data
    const msg = `üìÅ **Channels in ${teamName}:**\n\n` +
      `1. **General**\n` +
      `   üìù General team discussions\n` +
      `   üë• Public channel\n\n` +
      `2. **Announcements**\n` +
      `   üìù Team announcements and updates\n` +
      `   üë• Public channel\n\n` +
      `3. **Random**\n` +
      `   üìù Casual conversations\n` +
      `   üë• Public channel\n\n` +
      `‚ö†Ô∏è **Note:** This is simulated data. To show real channels:\n` +
      `- Implement the backend /channels/:teamId endpoint\n` +
      `- Configure Microsoft Graph permissions\n\n` +
      `üí° Use "Create a channel called '[name]' in ${teamName}" to create new channels.`;

    addMessage(msg, "bot");
    return msg;

  } catch (error) {
    const msg = `‚ùå Failed to get channels: ${error.message}`;
    addMessage(msg, "bot");
    return msg;
  }
}

      // ====================================================================
      // --- TOOL IMPLEMENTATIONS ---
      // ====================================================================

      async function handleCreateMeeting(params) {
        try {
          console.log("üìÖ Creating meeting with params:", params);

          // ENHANCED VALIDATION with better defaults
          if (!params.subject) {
            // Try to extract subject from description or use default
            params.subject = params.description || "Meeting";
          }

          if (!params.date) {
            // Default to tomorrow if no date specified
            params.date = "tomorrow";
            console.log("‚ö†Ô∏è No date specified, defaulting to tomorrow");
          }

          if (!params.time) {
            // Default to next hour if no time specified
            const nextHour = new Date();
            nextHour.setHours(nextHour.getHours() + 1, 0, 0, 0);
            params.time = nextHour.toLocaleTimeString("en-US", {
              hour: "numeric",
              minute: "2-digit",
              hour12: true,
            });
            console.log(`‚ö†Ô∏è No time specified, defaulting to ${params.time}`);
          }

          console.log("üìÖ Final params after validation:", params);

          // Enhanced date/time parsing
          const startTime = parseDateTime(params.date, params.time);
          console.log("üïê Parsed start time:", startTime);

          const endTime = new Date(
            new Date(startTime).getTime() + (params.duration || 30) * 60000
          ).toISOString();

          const attendees = params.attendees || [];

          // CRITICAL FIX: Detect if attendees contains names vs emails
          const isEmail = (str) => {
            return (
              str.includes("@") &&
              !str.includes(" ") &&
              str.split("@").length === 2
            );
          };

          // Separate names from emails
          const attendeeEmails = attendees.filter((attendee) =>
            isEmail(attendee)
          );
          const attendeeNames = attendees.filter(
            (attendee) => !isEmail(attendee)
          );

          console.log("üë• Attendee analysis:", {
            total: attendees.length,
            emails: attendeeEmails,
            names: attendeeNames,
            hasNames: attendeeNames.length > 0,
          });

          let payload;
          let endpoint;

          if (attendeeNames.length > 0) {
            // Use create-with-names endpoint for name resolution
            console.log("üîÑ Using name-based meeting creation");
            endpoint = `${API_BASE_URL}/meetings/create-with-names`;
            payload = {
              subject: params.subject,
              description:
                params.description ||
                `${params.subject} - Created with AI assistance`,
              startTime,
              endTime,
              attendeeNames: attendeeNames,
              attendeeEmails: attendeeEmails,
              autoJoinAgent: params.enableAutoInsights !== false,
              enableChatCapture: params.enableChatCapture !== false,
            };
          } else {
            // Use regular create endpoint for direct emails only
            console.log("üìß Using email-based meeting creation");
            endpoint = `${API_BASE_URL}/meetings/create`;
            payload = {
              subject: params.subject,
              description:
                params.description ||
                `${params.subject} - Created with AI assistance`,
              startTime,
              endTime,
              attendees: attendeeEmails,
              autoJoinAgent: params.enableAutoInsights !== false,
              enableChatCapture: params.enableChatCapture !== false,
            };
          }

          console.log("üì§ Sending payload to:", endpoint);
          console.log("üì¶ Payload:", payload);

          const response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          const data = await response.json();
          console.log("üì® Response:", data);

          if (!response.ok) {
            throw new Error(
              data.details || data.error || "Failed to create meeting"
            );
          }

          lastCreatedMeeting = data.meeting;
          userMeetings.unshift(data.meeting);

          if (params.enableAutoInsights !== false) {
            showAutoInsightsStatus(true);
          }

          const meetingCard = createMeetingCard(
            data.meeting,
            data.userResolution
          );
          addMessage(meetingCard, "bot", "card");

          let successMessage = `‚úÖ Meeting "${
            params.subject
          }" created successfully!\nüïê Scheduled for: ${new Date(
            startTime
          ).toLocaleString()}\nü§ñ Auto-insights: ${
            params.enableAutoInsights !== false ? "ENABLED" : "DISABLED"
          }`;

          if (data.userResolution && attendeeNames.length > 0) {
            successMessage += `\nüë• Name Resolution: ${data.userResolution.usersResolved}/${data.userResolution.namesRequested} names resolved from Teams directory`;
            successMessage += `\nüìß Final attendees: ${
              data.meeting.attendees?.length || 0
            } total`;
          } else {
            successMessage += `\nüë• Attendees: ${
              data.meeting.attendees?.length || 0
            }`;
          }

          return successMessage;
        } catch (error) {
          console.error("‚ùå Meeting creation error:", error);
          const msg = `‚ùå Failed to create meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetings(params) {
        try {
          // Fix: Provide default values for all parameters
          const limit = params?.limit || 10;
          const status = params?.status || null;
          const detailed = params?.detailed || false;

          let url = `${API_BASE_URL}/meetings?limit=${limit}`;
          if (status) {
            url += `&status=${status}`;
          }

          console.log("üìã Getting meetings with URL:", url);

          const response = await fetch(url);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meetings");
          }

          userMeetings = data.meetings || []; // Cache for other operations

          if (data.meetings.length === 0) {
            const msg = "üìÖ No meetings found. Would you like to schedule one?";
            addMessage(msg, "bot");
            return msg;
          }

          if (detailed) {
            // Show detailed meeting cards
            data.meetings.forEach((meeting) => {
              const card = createMeetingCard(meeting);
              addMessage(card, "bot", "card");
            });
            return `üìã Showing ${data.meetings.length} detailed meeting(s)`;
          } else {
            // Show compact list
            let resultMsg = `üìã **Your Meetings** (${data.meetings.length} found):\n\n`;
            data.meetings.forEach((meeting, index) => {
              const date = new Date(meeting.startTime).toLocaleString();
              const status = getStatusBadge(meeting.status);
              const insights = meeting.agentAttended ? "ü§ñ" : "üë§";

              resultMsg += `${index + 1}. **${meeting.subject}**\n`;
              resultMsg += `   ‚è∞ ${date}\n`;
              resultMsg += `   ${status} ${insights} ${
                meeting.attendees?.length || 0
              } attendees\n\n`;
            });

            addMessage(resultMsg, "bot");
            return resultMsg;
          }
        } catch (error) {
          console.error("‚ùå Get meetings error:", error);
          const msg = `‚ùå Failed to get meetings: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleJoinMeetingAgent(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/join-agent`,
            {
              method: "POST",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to join meeting");
          }

          showAutoInsightsStatus(true);

          const msg =
            `ü§ñ **AI Agent Joined Successfully!**\n\n` +
            `üìã Meeting: "${meeting.subject}"\n` +
            `‚úÖ Auto-insights activated\n` +
            `üí¨ Chat monitoring started\n` +
            `üìä Real-time analytics enabled\n` +
            `üìß Live updates will be sent to attendees\n\n` +
            `The AI agent is now visible to all participants and ready to provide insights!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to join meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleLeaveMeetingAgent(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/leave-agent`,
            {
              method: "POST",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to leave meeting");
          }

          showAutoInsightsStatus(false);

          const msg =
            `üèÅ **AI Agent Left Meeting**\n\n` +
            `üìã Meeting: "${meeting.subject}"\n` +
            `‚úÖ Session completed\n` +
            `üìä Final summary generated\n` +
            `üìß Comprehensive report sent to all attendees\n` +
            `üíæ All insights and analytics saved\n\n` +
            `Check your email for the detailed meeting summary!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to leave meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleCancelMeeting(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}`,
            {
              method: "DELETE",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to cancel meeting");
          }

          // Update local cache
          userMeetings = userMeetings.filter((m) => m.id !== meeting.id);

          const msg =
            `üóëÔ∏è **Meeting Cancelled Successfully**\n\n` +
            `üìã Meeting: "${meeting.subject}"\n` +
            `‚è∞ Was scheduled for: ${new Date(
              meeting.startTime
            ).toLocaleString()}\n` +
            `üë• ${
              meeting.attendees?.length || 0
            } attendees will be notified\n` +
            `‚úÖ Calendar has been updated\n\n` +
            `All participants will receive cancellation notifications.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to cancel meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingDetails(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/status`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting details");
          }

          const detailCard = createDetailedMeetingCard(
            data.meeting,
            data.timing,
            data.agentStatus
          );
          addMessage(detailCard, "bot", "card");

          return `üìã Detailed information for "${meeting.subject}" displayed above.`;
        } catch (error) {
          const msg = `‚ùå Failed to get meeting details: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingSummary(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          let url = `${API_BASE_URL}/meetings/${meeting.id}/summary`;
          if (params.regenerate) {
            url += `?regenerate=true`;
          }

          const response = await fetch(url);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting summary");
          }

          const summary = data.summary;
          let msg = `üìã **AI-Generated Meeting Summary**\n\n`;
          msg += `üè¢ **Meeting:** ${meeting.subject}\n`;
          msg += `üìÖ **Date:** ${new Date(
            meeting.startTime
          ).toLocaleString()}\n\n`;

          if (summary.executiveSummary) {
            msg += `üìù **Executive Summary:**\n${summary.executiveSummary}\n\n`;
          }

          if (summary.actionItems && summary.actionItems.length > 0) {
            msg += `‚úÖ **Action Items (${summary.actionItems.length}):**\n`;
            summary.actionItems.forEach((item, index) => {
              msg += `${index + 1}. ${item.task}\n`;
              if (item.assignee) msg += `   üë§ Assigned to: ${item.assignee}\n`;
              if (item.deadline) msg += `   üìÖ Due: ${item.deadline}\n`;
            });
            msg += `\n`;
          }

          if (summary.metrics) {
            msg += `üìä **Meeting Metrics:**\n`;
            msg += `‚Ä¢ Messages: ${summary.metrics.totalMessages || 0}\n`;
            msg += `‚Ä¢ Questions: ${summary.metrics.questionsAsked || 0}\n`;
            msg += `‚Ä¢ Decisions: ${summary.metrics.decisionsTracked || 0}\n\n`;
          }

          if (summary.qualityScores) {
            msg += `üéØ **Quality Score:** ${summary.qualityScores.overall}/10\n\n`;
          }

          msg += `ü§ñ Generated with AI auto-insights`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to get meeting summary: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingAnalysis(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/chat-analysis`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting analysis");
          }

          const analysis = data.analysis;
          let msg = `üìä **Meeting Chat Analysis**\n\n`;
          msg += `üè¢ **Meeting:** ${meeting.subject}\n`;
          msg += `üí¨ **Total Messages:** ${analysis.totalMessages}\n\n`;

          if (analysis.categorizedCounts) {
            msg += `üìà **Message Categories:**\n`;
            msg += `‚Ä¢ ‚ùì Questions: ${analysis.categorizedCounts.questions}\n`;
            msg += `‚Ä¢ ‚úÖ Action Items: ${analysis.categorizedCounts.actionItems}\n`;
            msg += `‚Ä¢ üéØ Decisions: ${analysis.categorizedCounts.decisions}\n`;
            msg += `‚Ä¢ üìé Shared Resources: ${analysis.categorizedCounts.sharedResources}\n\n`;
          }

          if (analysis.participantAnalysis) {
            msg += `üë• **Top Participants:**\n`;
            Object.entries(analysis.participantAnalysis)
              .sort(([, a], [, b]) => b.messageCount - a.messageCount)
              .slice(0, 3)
              .forEach(([name, stats]) => {
                msg += `‚Ä¢ **${name}**: ${stats.messageCount} messages\n`;
              });
            msg += `\n`;
          }

          if (analysis.keyInsights) {
            msg += `üí° **Key Insights:**\n`;
            if (analysis.keyInsights.mostActiveParticipant) {
              msg += `üèÜ Most Active: ${analysis.keyInsights.mostActiveParticipant}\n`;
            }
          }

          msg += `\nü§ñ Analysis powered by auto-insights AI`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to get meeting analysis: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleFindPeople(params) {
        try {
          // Fix: Ensure searchTerm is properly extracted
          const searchTerm = params.searchTerm || params.query || "John";

          console.log("üîç Searching for people with term:", searchTerm);

          const response = await fetch(
            `${API_BASE_URL}/users/search?q=${encodeURIComponent(
              searchTerm
            )}&limit=${params.limit || 10}`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to search people");
          }

          if (data.users.length === 0) {
            const msg = `üîç No team members found matching "${searchTerm}". Try a different search term.`;
            addMessage(msg, "bot");
            return msg;
          }

          let msg = `üë• **Found ${data.users.length} team member(s) for "${searchTerm}":**\n\n`;
          data.users.forEach((user, index) => {
            msg += `${index + 1}. **${user.name}**\n`;
            msg += `   üìß ${user.email}\n`;
            if (user.jobTitle) msg += `   üíº ${user.jobTitle}\n`;
            if (user.department) msg += `   üè¢ ${user.department}\n`;
            msg += `\n`;
          });

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          console.error("‚ùå Find people error:", error);
          const msg = `‚ùå Failed to find people: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetTeamMembers(params) {
        try {
          // Fix: Provide default values
          const limit = params?.limit || 20;
          const includeDetails = params?.includeDetails || true;

          console.log("üë• Getting team members with limit:", limit);

          const response = await fetch(`${API_BASE_URL}/users?limit=${limit}`);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get team members");
          }

          if (!data.users || data.users.length === 0) {
            const msg = "üë• No team members found in the directory.";
            addMessage(msg, "bot");
            return msg;
          }

          let msg = `üë• **Team Directory** (${
            data.total || data.users.length
          } total members):\n\n`;
          data.users.slice(0, 15).forEach((user, index) => {
            msg += `${index + 1}. **${user.name}**\n`;
            msg += `   üìß ${user.email}\n`;
            if (includeDetails) {
              if (user.jobTitle) msg += `   üíº ${user.jobTitle}\n`;
              if (user.department) msg += `   üè¢ ${user.department}\n`;
            }
            msg += `\n`;
          });

          if (data.total > 15) {
            msg += `... and ${data.total - 15} more members\n\n`;
          }

          msg += `üí° Use "find people named [name]" to search for specific team members.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          console.error("‚ùå Get team members error:", error);
          const msg = `‚ùå Failed to get team members: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleSendMessage(params) {
        try {
          const response = await fetch(`${API_BASE_URL}/users/resolve`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ names: [params.recipient] }),
          });

          const userData = await response.json();
          if (!response.ok || userData.resolvedUsers.length === 0) {
            throw new Error(`Could not find user: ${params.recipient}`);
          }

          const resolvedUser = userData.resolvedUsers[0];

          // In a real implementation, you would send the message via Teams/email
          // For now, we'll simulate the message sending
          const msg =
            `‚úÖ **Message Sent Successfully!**\n\n` +
            `üë§ **To:** ${resolvedUser.name}\n` +
            `üìß **Email:** ${resolvedUser.email}\n` +
            `üí¨ **Message:** "${params.message}"\n\n` +
            `üì¨ Your message has been delivered and they should receive it shortly.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to send message: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleResolveUsers(params) {
        try {
          const response = await fetch(`${API_BASE_URL}/users/resolve`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ names: params.names }),
          });

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to resolve users");
          }

          let msg = `üîç **User Resolution Results:**\n\n`;
          msg += `üìä Success Rate: ${data.summary?.successRate || "N/A"}\n`;
          msg += `‚úÖ Found: ${data.resolvedUsers.length}/${params.names.length}\n\n`;

          if (data.resolvedUsers.length > 0) {
            msg += `**Resolved Users:**\n`;
            data.resolvedUsers.forEach((user, index) => {
              msg += `${index + 1}. **${user.name}** ‚Üí ${user.email}\n`;
            });
          }

          if (data.resolvedUsers.length < params.names.length) {
            const notFound = params.names.filter(
              (name) =>
                !data.resolvedUsers.some((user) =>
                  user.name.toLowerCase().includes(name.toLowerCase())
                )
            );
            msg += `\n‚ùå **Not Found:** ${notFound.join(", ")}`;
          }

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to resolve users: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleSuggestMeetingTimes(params) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/meetings/suggest-times`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                attendees: params.attendees,
                duration: params.duration || 30,
              }),
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting suggestions");
          }

          let msg = `üïê **Optimal Meeting Times**\n\n`;
          msg += `üë• Checked availability for ${params.attendees.length} attendees\n`;
          msg += `‚è±Ô∏è Duration: ${params.duration || 30} minutes\n\n`;

          if (data.suggestions && data.suggestions.length > 0) {
            msg += `**üìÖ Suggested Times:**\n`;
            data.suggestions.slice(0, 5).forEach((suggestion, index) => {
              const startTime = new Date(suggestion.startTime).toLocaleString();
              const endTime = new Date(suggestion.endTime).toLocaleString();
              msg += `${index + 1}. ${startTime} - ${endTime}\n`;
              if (suggestion.confidence) {
                msg += `   üìä Confidence: ${Math.round(
                  suggestion.confidence * 100
                )}%\n`;
              }
            });
          } else {
            msg += `‚ùå No optimal times found. Try different attendees or duration.`;
          }

          msg += `\n\nüí° Use these times when creating your meeting for best attendance!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to suggest meeting times: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      // ====================================================================
      // --- UTILITY FUNCTIONS ---
      // ====================================================================

      async function findMeetingByIdentifier(identifier) {
        // First try to get fresh meeting list
        try {
          const response = await fetch(`${API_BASE_URL}/meetings?limit=20`);
          const data = await response.json();
          if (response.ok) {
            userMeetings = data.meetings;
          }
        } catch (error) {
          console.warn("Could not refresh meeting list:", error);
        }

        if (
          identifier.toLowerCase() === "latest" ||
          identifier.toLowerCase() === "recent"
        ) {
          if (userMeetings.length === 0) {
            throw new Error("No meetings found. Create a meeting first.");
          }
          return userMeetings[0]; // Most recent
        }

        // Try to find by ID first
        let meeting = userMeetings.find(
          (m) => m.id === identifier || m.meetingId === identifier
        );

        // If not found, try by subject (partial match)
        if (!meeting) {
          meeting = userMeetings.find((m) =>
            m.subject.toLowerCase().includes(identifier.toLowerCase())
          );
        }

        if (!meeting) {
          throw new Error(
            `Meeting not found: "${identifier}". Try using the exact meeting subject or "latest".`
          );
        }

        return meeting;
      }

      // ====================================================================
      // --- COMPREHENSIVE DATE/TIME PARSING FUNCTION ---
      // ====================================================================

      function parseDateTime(dateStr, timeStr) {
        console.log("üïê Parsing date/time:", { dateStr, timeStr });

        const now = new Date();
        let meetingDate = new Date(now);

        // ============ ENHANCED DATE PARSING ============
        if (dateStr) {
          const dateLower = dateStr.toLowerCase().trim();
          let dateResolved = false;

          // Relative dates
          if (dateLower === "today") {
            meetingDate = new Date(now);
            dateResolved = true;
          } else if (dateLower === "tomorrow") {
            meetingDate = new Date(now);
            meetingDate.setDate(now.getDate() + 1);
            dateResolved = true;
          } else if (dateLower.includes("next week")) {
            meetingDate = new Date(now);
            meetingDate.setDate(now.getDate() + 7);
            dateResolved = true;
          }

          // Weekdays
          const weekdays = {
            monday: 1,
            tuesday: 2,
            wednesday: 3,
            thursday: 4,
            friday: 5,
            saturday: 6,
            sunday: 0,
          };

          for (const [day, dayNum] of Object.entries(weekdays)) {
            if (dateLower.includes(day)) {
              meetingDate = getNextWeekday(now, dayNum);
              dateResolved = true;
              break;
            }
          }

          // Month names parsing (comprehensive)
          if (!dateResolved) {
            const monthNames = {
              january: 0,
              jan: 0,
              february: 1,
              feb: 1,
              march: 2,
              mar: 2,
              april: 3,
              apr: 3,
              may: 4,
              june: 5,
              jun: 5,
              july: 6,
              jul: 6,
              august: 7,
              aug: 7,
              september: 8,
              sep: 8,
              october: 9,
              oct: 9,
              november: 10,
              nov: 10,
              december: 11,
              dec: 11,
            };

            // Patterns: "15 august", "august 15", "15th august", "aug 15"
            const patterns = [
              /(\d{1,2})(?:st|nd|rd|th)?\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
              /(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})(?:st|nd|rd|th)?/i,
            ];

            for (const pattern of patterns) {
              const match = dateLower.match(pattern);
              if (match) {
                let day, monthName;
                if (/\d/.test(match[1])) {
                  day = parseInt(match[1]);
                  monthName = match[2].toLowerCase();
                } else {
                  day = parseInt(match[2]);
                  monthName = match[1].toLowerCase();
                }

                const monthIndex = monthNames[monthName];
                if (monthIndex !== undefined && day >= 1 && day <= 31) {
                  meetingDate = new Date(now.getFullYear(), monthIndex, day);

                  // If date is in the past, move to next year
                  if (
                    meetingDate <
                    new Date(now.getFullYear(), now.getMonth(), now.getDate())
                  ) {
                    meetingDate.setFullYear(now.getFullYear() + 1);
                  }
                  dateResolved = true;
                  break;
                }
              }
            }
          }

          // Numeric date patterns: "15/8", "8/15", "15-8", "2025-08-15"
          if (!dateResolved) {
            const numericPatterns = [
              /(\d{4})-(\d{1,2})-(\d{1,2})/, // YYYY-MM-DD
              /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, // DD/MM/YYYY or MM/DD/YYYY
              /(\d{1,2})[\/\-](\d{1,2})/, // DD/MM or MM/DD
            ];

            for (const pattern of numericPatterns) {
              const match = dateStr.match(pattern);
              if (match) {
                let year, month, day;

                if (match[0].includes(match[1]) && match[1].length === 4) {
                  // YYYY-MM-DD format
                  year = parseInt(match[1]);
                  month = parseInt(match[2]) - 1;
                  day = parseInt(match[3]);
                } else if (match[3]) {
                  // With year
                  year = parseInt(match[3]);
                  // Assume DD/MM/YYYY for ambiguous cases
                  day = parseInt(match[1]);
                  month = parseInt(match[2]) - 1;
                } else {
                  // Without year - assume current year
                  year = now.getFullYear();
                  // Decide between DD/MM and MM/DD
                  const num1 = parseInt(match[1]);
                  const num2 = parseInt(match[2]);

                  if (num1 > 12) {
                    day = num1;
                    month = num2 - 1;
                  } else if (num2 > 12) {
                    day = num2;
                    month = num1 - 1;
                  } else {
                    // Both <= 12, assume DD/MM
                    day = num1;
                    month = num2 - 1;
                  }
                }

                meetingDate = new Date(year, month, day);
                if (!isNaN(meetingDate.getTime())) {
                  if (
                    meetingDate <
                    new Date(now.getFullYear(), now.getMonth(), now.getDate())
                  ) {
                    meetingDate.setFullYear(now.getFullYear() + 1);
                  }
                  dateResolved = true;
                  break;
                }
              }
            }
          }

          // Fallback: try native Date parsing
          if (!dateResolved) {
            const fallbackFormats = [
              `${dateStr} ${now.getFullYear()}`,
              `${now.getFullYear()}-${dateStr}`,
              dateStr,
            ];

            for (const format of fallbackFormats) {
              const testDate = new Date(format);
              if (
                !isNaN(testDate.getTime()) &&
                testDate.getFullYear() >= now.getFullYear()
              ) {
                meetingDate = testDate;
                dateResolved = true;
                break;
              }
            }
          }
        }

        // ============ ENHANCED TIME PARSING ============
        if (timeStr) {
          const timeLower = timeStr.toLowerCase().trim();
          console.log("üïê Parsing time:", timeLower);

          let hours = null;
          let minutes = 0;

          // Comprehensive time patterns
          const timePatterns = [
            // 12-hour format with AM/PM
            /(\d{1,2}):(\d{2})\s*(am|pm)/i, // 2:30pm, 10:15am
            /(\d{1,2})\s*(am|pm)/i, // 2pm, 10am
            /(\d{1,2})\.(\d{2})\s*(am|pm)/i, // 2.30pm

            // 24-hour format
            /(\d{1,2}):(\d{2})$/, // 14:30, 02:15
            /(\d{1,2})\.(\d{2})$/, // 14.30, 02.15
            /(\d{1,2})h(\d{2})/i, // 14h30, 2h15
            /(\d{1,2})h$/i, // 14h, 2h

            // Simple hour formats
            /^(\d{1,2})$/, // 14, 2 (assume 24h if >12, otherwise next occurrence)
          ];

          for (const pattern of timePatterns) {
            const match = timeLower.match(pattern);
            if (match) {
              hours = parseInt(match[1], 10);
              minutes = match[2] ? parseInt(match[2], 10) : 0;

              // Handle AM/PM conversion
              if (match[3]) {
                const period = match[3].toLowerCase();
                if (period === "pm" && hours < 12) {
                  hours += 12;
                } else if (period === "am" && hours === 12) {
                  hours = 0;
                }
              } else if (
                hours <= 12 &&
                !timeLower.includes(":") &&
                !timeLower.includes(".") &&
                !timeLower.includes("h")
              ) {
                // For simple hour format, assume PM if it's a reasonable time
                if (hours >= 8 && hours <= 11) {
                  // Could be AM or PM, check context
                  const currentHour = now.getHours();
                  if (currentHour >= 12) {
                    hours += 12; // Assume PM if it's afternoon
                  }
                }
              }

              // Validate time
              if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
                break;
              } else {
                hours = null; // Invalid time, continue to next pattern
              }
            }
          }

          // Special cases for common time expressions
          if (hours === null) {
            const specialTimes = {
              morning: [9, 0],
              noon: [12, 0],
              afternoon: [14, 0],
              evening: [18, 0],
              night: [20, 0],
              midnight: [0, 0],
            };

            for (const [timeWord, [h, m]] of Object.entries(specialTimes)) {
              if (timeLower.includes(timeWord)) {
                hours = h;
                minutes = m;
                break;
              }
            }
          }

          // Apply time to meeting date
          if (hours !== null) {
            meetingDate.setHours(hours, minutes, 0, 0);
            console.log("üïê Set time to:", hours, ":", minutes);
          } else {
            console.warn("‚ö†Ô∏è Could not parse time:", timeStr);
            // Default to next hour
            const nextHour = new Date(now.getTime() + 3600000);
            meetingDate.setHours(nextHour.getHours(), 0, 0, 0);
          }
        } else {
          // No time specified - default to next reasonable hour
          const nextHour = new Date(now.getTime() + 3600000);
          meetingDate.setHours(nextHour.getHours(), 0, 0, 0);
        }

        // ============ FINAL VALIDATION ============
        // Ensure the meeting is in the future
        if (meetingDate.getTime() <= now.getTime()) {
          if (dateStr && timeStr) {
            // Both date and time specified but in past - move to next occurrence
            meetingDate.setDate(meetingDate.getDate() + 1);
          } else {
            // Only time specified or default - move to next valid time
            meetingDate = new Date(now.getTime() + 3600000); // 1 hour from now
          }
        }

        const result = meetingDate.toISOString();
        console.log(
          "üïê Final parsed datetime:",
          result,
          "Local:",
          meetingDate.toLocaleString()
        );
        return result;
      }

      // Helper function to get next occurrence of a weekday
      function getNextWeekday(date, targetDay) {
        const result = new Date(date);
        const currentDay = result.getDay();
        let daysToAdd = targetDay - currentDay;

        if (daysToAdd <= 0) {
          daysToAdd += 7; // Next week
        }

        result.setDate(result.getDate() + daysToAdd);
        return result;
      }

      function getStatusBadge(status) {
        const badges = {
          scheduled: "üìÖ Scheduled",
          in_progress: "üü¢ In Progress",
          completed: "‚úÖ Completed",
          cancelled: "‚ùå Cancelled",
        };
        return badges[status] || "‚ùî Unknown";
      }

      function getCapabilitiesOverview() {
        return `**ü§ñ My Capabilities:**

**üìÖ Meeting Management:**
‚Ä¢ Schedule Teams meetings with auto-insights
‚Ä¢ View, cancel, and manage your meetings
‚Ä¢ Get detailed meeting information and status

**ü§ñ AI Agent Features:**
‚Ä¢ Join meetings for live monitoring and insights
‚Ä¢ Generate comprehensive meeting summaries
‚Ä¢ Analyze meeting chat and participant engagement

**üë• Team Collaboration:**
‚Ä¢ Find and search team members
‚Ä¢ Send messages to colleagues
‚Ä¢ Resolve names to email addresses

**üí° Smart Features:**
‚Ä¢ Suggest optimal meeting times
‚Ä¢ Auto-insights with real-time notifications
‚Ä¢ Meeting analytics and quality scoring

Try commands like:
‚Ä¢ "Schedule a meeting tomorrow at 2pm with John"
‚Ä¢ "Show my recent meetings"
‚Ä¢ "Join AI agent to my latest meeting"
‚Ä¢ "Find team members named Sarah"`;
      }

      // ====================================================================
      // --- UI COMPONENTS ---
      // ====================================================================

      function createMeetingCard(meeting, userResolution = null) {
        const attendeesText = userResolution
          ? `${userResolution.usersResolved}/${userResolution.namesRequested} resolved`
          : `${meeting.attendees?.length || 0} attendees`;

        const insightsStatus = meeting.agentAttended
          ? "‚úÖ ENABLED"
          : "‚ö†Ô∏è DISABLED";
        const startTime = new Date(meeting.startTime).toLocaleString();

        return {
          type: "AdaptiveCard",
          version: "1.4",
          body: [
            {
              type: "TextBlock",
              text: "üìÖ Meeting Created Successfully!",
              weight: "Bolder",
              size: "Medium",
              color: "Good",
            },
            {
              type: "TextBlock",
              text: meeting.subject,
              weight: "Bolder",
              size: "Large",
              wrap: true,
            },
            {
              type: "TextBlock",
              text: `üïê ${startTime}`,
              spacing: "Small",
              wrap: true,
            },
            {
              type: "FactSet",
              spacing: "Medium",
              facts: [
                { title: "üë• Attendees:", value: attendeesText },
                { title: "ü§ñ Auto-Insights:", value: insightsStatus },
                { title: "üìä Status:", value: getStatusBadge(meeting.status) },
                { title: "üîó Meeting Type:", value: "Microsoft Teams" },
              ],
            },
          ],
          actions: [
            {
              type: "Action.OpenUrl",
              title: "üîó Join Meeting",
              url: meeting.joinUrl || "#",
              style: "positive",
            },
            {
              type: "Action.OpenUrl",
              title: "üìÖ View in Calendar",
              url: meeting.webUrl || "#",
            },
          ],
        };
      }

      function createDetailedMeetingCard(meeting, timing, agentStatus) {
        return {
          type: "AdaptiveCard",
          version: "1.4",
          body: [
            {
              type: "TextBlock",
              text: "üìã Meeting Details",
              weight: "Bolder",
              size: "Medium",
              color: "Accent",
            },
            {
              type: "TextBlock",
              text: meeting.subject,
              weight: "Bolder",
              size: "Large",
              wrap: true,
            },
            {
              type: "FactSet",
              spacing: "Medium",
              facts: [
                {
                  title: "üìÖ Start Time:",
                  value: new Date(meeting.startTime).toLocaleString(),
                },
                {
                  title: "‚è∞ End Time:",
                  value: new Date(meeting.endTime).toLocaleString(),
                },
                { title: "üìä Status:", value: getStatusBadge(meeting.status) },
                {
                  title: "üë• Attendees:",
                  value: `${meeting.attendees?.length || 0}`,
                },
                {
                  title: "ü§ñ AI Agent:",
                  value: agentStatus.isAttending ? "Active" : "Inactive",
                },
                {
                  title: "‚è±Ô∏è Duration:",
                  value: `${timing.meetingDuration} minutes`,
                },
              ],
            },
            {
              type: "TextBlock",
              text: timing.hasStarted
                ? timing.hasEnded
                  ? "‚úÖ Meeting completed"
                  : "üü¢ Meeting in progress"
                : `‚è≥ Starts in ${Math.abs(timing.minutesUntilStart)} minutes`,
              spacing: "Medium",
              wrap: true,
              color: timing.hasStarted
                ? timing.hasEnded
                  ? "Good"
                  : "Attention"
                : "Default",
            },
          ],
          actions:
            meeting.status === "scheduled"
              ? [
                  {
                    type: "Action.OpenUrl",
                    title: "üîó Join Meeting",
                    url: meeting.joinUrl || "#",
                    style: "positive",
                  },
                ]
              : [],
        };
      }

      function showAutoInsightsStatus(active) {
        autoInsightsActive = active;
        if (active) {
          ui.autoInsightsStatus.classList.add("auto-insights-active");
          ui.autoInsightsStatus.textContent = "ü§ñ Auto-Insights Active";
        } else {
          ui.autoInsightsStatus.classList.remove("auto-insights-active");
          ui.autoInsightsStatus.textContent = "ü§ñ Auto-Insights Inactive";
        }
      }

      function showLoading(show = true) {
        const existing = document.getElementById("loading-indicator");
        if (existing) existing.remove();

        if (show) {
          const loadingMessages = [
            "ü§ñ AI processing your request...",
            "üß† Analyzing with auto-insights...",
            "‚ö° Working on that for you...",
            "üöÄ AI agent is on it...",
            "üí≠ Preparing intelligent response...",
          ];

          const loadingMessage =
            loadingMessages[Math.floor(Math.random() * loadingMessages.length)];

          const loadingWrapper = document.createElement("div");
          loadingWrapper.id = "loading-indicator";
          loadingWrapper.className = "flex mb-4 justify-start";
          loadingWrapper.innerHTML = `
            <div class="max-w-lg px-4 py-3 rounded-2xl bg-slate-200 text-slate-800 flex items-center space-x-2">
              <div class="typing-indicator flex space-x-1">
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce"></div>
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
              </div>
              <span class="text-sm">${loadingMessage}</span>
            </div>
          `;
          ui.chatContainer.appendChild(loadingWrapper);
          ui.chatContainer.scrollTop = ui.chatContainer.scrollHeight;
        }
      }

      async function addMessage(content, sender, type = "text") {
        const messageWrapper = document.createElement("div");
        messageWrapper.className = `flex mb-4 ${
          sender === "user" ? "justify-end" : "justify-start"
        }`;

        const messageContent = document.createElement("div");
        messageWrapper.appendChild(messageContent);
        ui.chatContainer.appendChild(messageWrapper);

        if (type === "card" && sender === "bot") {
          messageContent.className = "max-w-lg lg:max-w-xl";
          try {
            await waitForAdaptiveCards();
            const adaptiveCard = new AdaptiveCards.AdaptiveCard();
            adaptiveCard.hostConfig = new AdaptiveCards.HostConfig({
              fontFamily: "Inter, sans-serif",
            });
            adaptiveCard.parse(content);
            const renderedCard = adaptiveCard.render();
            renderedCard.classList.add("adaptive-card");
            messageContent.appendChild(renderedCard);
          } catch (error) {
            console.error("Adaptive Card rendering failed:", error);
            messageContent.className =
              "max-w-lg lg:max-w-xl px-4 py-3 rounded-2xl bg-slate-200 text-slate-800 whitespace-pre-wrap";
            messageContent.textContent = `Meeting: ${
              content.body?.[1]?.text || "Created Successfully"
            }`;
          }
        } else {
          messageContent.className = `max-w-lg lg:max-w-xl px-4 py-3 rounded-2xl ${
            sender === "user"
              ? "bg-gradient-to-r from-blue-500 to-purple-600 text-white"
              : "bg-slate-200 text-slate-800"
          }`;

          if (typeof content === "object") {
            messageContent.textContent = "Meeting information displayed above.";
          } else {
            const formattedContent = content
              .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
              .replace(/\n/g, "<br>");
            messageContent.innerHTML = formattedContent;
          }
        }

        ui.chatContainer.scrollTop = ui.chatContainer.scrollHeight;
      }

      function waitForAdaptiveCards() {
        return new Promise((resolve, reject) => {
          let retries = 0;
          const maxRetries = 40;
          const interval = setInterval(() => {
            if (window.AdaptiveCards && window.AdaptiveCards.AdaptiveCard) {
              clearInterval(interval);
              resolve();
            } else {
              retries++;
              if (retries > maxRetries) {
                clearInterval(interval);
                reject(new Error("Adaptive Cards library failed to load."));
              }
            }
          }, 250);
        });
      }

      // ====================================================================
      // --- EVENT HANDLERS AND INITIALIZATION ---
      // ====================================================================

      function sendQuickMessage(message) {
        ui.messageInput.value = message;
        handleUserMessage(message);
        ui.messageInput.value = "";
      }

      async function checkApiStatus() {
        // Remove all the fetch logic and just enable the interface
        ui.messageInput.disabled = false;
        ui.sendButton.disabled = false;

        const welcomeMessages = [
          `üöÄ **Welcome to Agent 365** - Your Intelligent Meeting Assistant!

**ü§ñ Advanced AI Capabilities:**
‚ú® Smart meeting scheduling with improved date/time parsing
üìä Real-time meeting analytics and monitoring  
üí¨ Intelligent chat analysis and summaries
üéØ Automatic action item and decision tracking
üìß Live email notifications and updates

**üìÖ Meeting Management:**
- Schedule Teams meetings with precise date/time handling
- View, cancel, and manage all your meetings
- Get detailed meeting status and information
- Join AI agent for live monitoring and insights

**üë• Team Collaboration:**
- Find and search team members across your organization
- Send messages to colleagues by name
- Resolve user names to email addresses automatically

**üí° Enhanced Date/Time Examples:**
- "Schedule a meeting tomorrow at 2pm with John Smith"
- "Create meeting next Monday at 10:30am about project review"
- "Book meeting January 15 at 3pm with the team"
- "Set up meeting Friday at 14:00 for status update"

**üéØ Pro Tips:**
- I now understand natural date/time formats better
- Use specific times like "2:30pm", "14:30", or "2pm"
- Mention weekdays like "next Monday" or "Friday"
- Include meeting topics for better organization

Ready to revolutionize your meeting experience with improved scheduling! üéâ`,
        ];

        const welcomeMsg =
          welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
        addMessage(welcomeMsg, "bot");
      }

      // Event Listeners
      ui.chatForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const message = ui.messageInput.value.trim();
        if (message) {
          handleUserMessage(message);
          ui.messageInput.value = "";
        }
      });

      // Enhanced keyboard shortcuts
      ui.messageInput.addEventListener("keydown", (e) => {
        if (e.key === "Tab") {
          e.preventDefault();
          // Cycle through common commands with improved examples
          const suggestions = [
            "Schedule a meeting tomorrow at 2pm with ",
            "Create meeting next Monday at 10am about ",
            "Show my recent meetings",
            "Find team members named ",
            "Join AI agent to my latest meeting",
            "Get summary of my last meeting",
          ];
          const currentValue = ui.messageInput.value;
          const nextSuggestion =
            suggestions.find((s) => s.startsWith(currentValue)) ||
            suggestions[0];
          ui.messageInput.value = nextSuggestion;
        }
      });

      // Auto-save draft messages
      ui.messageInput.addEventListener("input", (e) => {
        localStorage.setItem("agent365_draft", e.target.value);
      });

      // Restore draft on load
      document.addEventListener("DOMContentLoaded", () => {
        const draft = localStorage.getItem("agent365_draft");
        if (draft) {
          ui.messageInput.value = draft;
        }
        checkApiStatus();
      });

      // Clear draft on send
      ui.chatForm.addEventListener("submit", () => {
        localStorage.removeItem("agent365_draft");
      });

      // Add some helpful tooltips and interactions
      document.addEventListener("DOMContentLoaded", () => {
        // Add tooltip functionality
        const addTooltip = (element, text) => {
          element.addEventListener("mouseenter", () => {
            const tooltip = document.createElement("div");
            tooltip.className =
              "absolute bg-gray-800 text-white text-xs rounded py-1 px-2 z-50";
            tooltip.textContent = text;
            tooltip.style.bottom = "100%";
            tooltip.style.left = "50%";
            tooltip.style.transform = "translateX(-50%)";
            element.style.position = "relative";
            element.appendChild(tooltip);
          });

          element.addEventListener("mouseleave", () => {
            const tooltip = element.querySelector(".absolute");
            if (tooltip) tooltip.remove();
          });
        };

        // Add tooltips to quick action buttons
        const quickButtons = document.querySelectorAll("#quick-actions button");
        const tooltips = [
          "Create a new Teams meeting with improved date/time parsing",
          "View your recent meetings and their status",
          "Search for colleagues in your organization",
          "Send a message to a team member",
          "Add AI agent to monitor your meeting",
          "Generate AI-powered meeting summary",
        ];

        quickButtons.forEach((button, index) => {
          if (tooltips[index]) {
            addTooltip(button, tooltips[index]);
          }
        });
      });

      // Initialize connection check
      document.addEventListener("DOMContentLoaded", () => {
        setTimeout(checkApiStatus, 500); // Small delay to ensure DOM is ready
      });

      // Add some Easter eggs and fun interactions
      let easterEggCount = 0;
      ui.messageInput.addEventListener("input", (e) => {
        if (e.target.value.toLowerCase().includes("hello agent")) {
          easterEggCount++;
          if (easterEggCount === 3) {
            addMessage(
              "üéâ You found an Easter egg! I love when people are polite! ü§ñ‚ú®",
              "bot"
            );
            easterEggCount = 0;
          }
        }
      });

      // Add help command detection
      const originalHandleUserMessage = handleUserMessage;
      handleUserMessage = async function (message) {
        const lowerMessage = message.toLowerCase();

        // Quick help responses
        if (
          lowerMessage === "help" ||
          lowerMessage === "?" ||
          lowerMessage === "/help"
        ) {
          const helpMsg = `ü§ñ **Agent 365 Quick Help**

**üìÖ Meeting Commands (Improved Date/Time Parsing):**
‚Ä¢ "Schedule a meeting [date] at [time] with [people] about [topic]"
‚Ä¢ "Create meeting tomorrow at 2:30pm with John about project review"
‚Ä¢ "Book meeting next Monday at 10am with the team"
‚Ä¢ "Set up meeting January 15 at 14:30 for status update"
‚Ä¢ "Show my meetings" or "List my recent meetings"
‚Ä¢ "Cancel my meeting about [subject]"

**ü§ñ AI Agent Commands:**
‚Ä¢ "Join agent to my [meeting]" - Start live monitoring
‚Ä¢ "Leave agent from my [meeting]" - Stop monitoring
‚Ä¢ "Get summary of my [meeting]" - AI-generated summary
‚Ä¢ "Analyze my [meeting]" - Chat analysis and insights

**üë• People Commands:**
‚Ä¢ "Find people named [name]"
‚Ä¢ "Show team members"
‚Ä¢ "Send message to [name]: [message]"
‚Ä¢ "Resolve users [name1, name2]"

**üïê Date/Time Formats I Understand:**
‚Ä¢ Relative: "today", "tomorrow", "next Monday", "next week"
‚Ä¢ Specific: "January 15", "2025-01-15", "Friday"
‚Ä¢ Times: "2pm", "14:30", "2:30pm", "10am", "3:00 PM"

**üí° Pro Tips:**
‚Ä¢ Use "latest" or "recent" to refer to your most recent meeting
‚Ä¢ I can understand natural language - just tell me what you need!
‚Ä¢ All meetings are created with auto-insights by default
‚Ä¢ I can resolve names to emails automatically
‚Ä¢ Date/time parsing is now much more accurate!

**üÜò Need more help?** Just ask me anything in natural language!`;

          addMessage(helpMsg, "bot");
          return;
        }

        // Status command
        if (lowerMessage === "status" || lowerMessage === "/status") {
          try {
            const response = await fetch(`${API_BASE_URL}/meetings/status`);
            const data = await response.json();

            const statusMsg = `üìä **Agent 365 System Status**

**üîß Core Services:**
‚Ä¢ Teams Integration: ${
              data.services.teams.available ? "üü¢ ACTIVE" : "üî¥ OFFLINE"
            }
‚Ä¢ AI Engine: ${data.services.ai.available ? "üü¢ ACTIVE" : "üî¥ OFFLINE"}
‚Ä¢ Auto-Insights: ${
              data.pocFeatures.realAiAgentJoin ? "üü¢ READY" : "üî¥ DISABLED"
            }
‚Ä¢ Enhanced Date/Time Parser: üü¢ ACTIVE

**üìà Available Features:**
‚Ä¢ Real Meeting Scheduling: ${
              data.pocFeatures.realMeetingScheduling ? "‚úÖ" : "‚ùå"
            }
‚Ä¢ User Resolution: ${data.pocFeatures.realUserResolution ? "‚úÖ" : "‚ùå"}
‚Ä¢ AI Agent Join: ${data.pocFeatures.realAiAgentJoin ? "‚úÖ" : "‚ùå"}
‚Ä¢ Chat Capture: ${data.pocFeatures.realChatCapture ? "‚úÖ" : "‚ùå"}
‚Ä¢ Summary Generation: ${data.pocFeatures.realSummaryGeneration ? "‚úÖ" : "‚ùå"}
‚Ä¢ Improved Date/Time Parsing: ‚úÖ

**üíæ Session Info:**
‚Ä¢ Session ID: ${sessionId}
‚Ä¢ Messages: ${conversationHistory.length}
‚Ä¢ Auto-Insights: ${autoInsightsActive ? "üü¢ Active" : "üî¥ Inactive"}

**üåê API Endpoint:** ${API_BASE_URL}`;

            addMessage(statusMsg, "bot");
            return;
          } catch (error) {
            addMessage(
              "‚ùå Could not retrieve system status. Please check connectivity.",
              "bot"
            );
            return;
          }
        }

        // Default to original handler
        return originalHandleUserMessage(message);
      };

      // Add version info
      console.log(`
ü§ñ Agent 365 - AI Meeting Assistant
üìÖ Version: 2.1.0 with Enhanced Date/Time Parsing
üîß Teams Integration: Active
üí° AI Engine: Gemini 2.0 Flash
üïê Date/Time Parser: Enhanced v2.1
üåê API: ${API_BASE_URL}
      `);
    </script>
  </body>
</html>
