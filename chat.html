<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent 365 - AI Meeting Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script
      src="https://unpkg.com/adaptivecards/dist/adaptivecards.min.js"
      crossorigin="anonymous"
    ></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      .adaptive-card {
        border-radius: 0.5rem;
        border: 1px solid #e5e7eb;
      }
      .chat-container::-webkit-scrollbar {
        width: 8px;
      }
      .chat-container::-webkit-scrollbar-track {
        background: #f1f5f9;
      }
      .chat-container::-webkit-scrollbar-thumb {
        background: #94a3b8;
        border-radius: 4px;
      }
      .typing-indicator {
        animation: pulse 1.5s ease-in-out infinite;
      }
      .auto-insights-status {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        margin-left: 10px;
        display: none;
      }
      .auto-insights-active {
        display: inline-block;
        animation: pulse 2s infinite;
      }
      .meeting-card {
        background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        border: 2px solid #0ea5e9;
        border-radius: 12px;
        padding: 16px;
        margin: 8px 0;
      }
      .action-button {
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        color: white;
        padding: 8px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        margin: 4px;
        transition: all 0.3s ease;
      }
      .action-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }
      .status-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
      }
      .status-scheduled {
        background: #dbeafe;
        color: #1e40af;
      }
      .status-in-progress {
        background: #dcfce7;
        color: #166534;
      }
      .status-completed {
        background: #f3e8ff;
        color: #7c3aed;
      }
      .status-cancelled {
        background: #fee2e2;
        color: #dc2626;
      }
    </style>
  </head>
  <body
    class="bg-slate-100 flex flex-col items-center justify-center h-screen p-4"
  >
    <div
      class="w-full max-w-6xl mx-auto flex flex-col h-full bg-white rounded-2xl shadow-2xl"
    >
      <!-- Enhanced Header with Auto-Insights Status -->
      <div
        class="p-4 border-b border-slate-200 flex justify-between items-center"
      >
        <div class="flex items-center space-x-3">
          <div
            class="p-2 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6 text-white"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2 2v10a2 2 0 002 2z"
              />
            </svg>
          </div>
          <div>
            <h1 class="text-lg font-bold text-slate-800">Agent 365</h1>
            <p class="text-sm text-slate-500">
              AI Meeting Assistant with Teams Integration
            </p>
          </div>
          <!-- Auto-Insights Status Indicator -->
          <div class="auto-insights-status" id="auto-insights-status">
            ğŸ¤– Auto-Insights Active
          </div>
        </div>
      </div>

      <!-- Chat Messages -->
      <div
        id="chat-container"
        class="flex-1 p-6 overflow-y-auto chat-container"
      ></div>

      <!-- Enhanced Message Input -->
      <div class="p-4 border-t border-slate-200 bg-slate-50">
        <div class="flex flex-wrap gap-2 mb-3" id="quick-actions">
          <button
            onclick="sendQuickMessage('Create a meeting tomorrow at 2pm with John Smith about project review')"
            class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-xs hover:bg-blue-200"
          >
            ğŸ—“ï¸ Schedule Meeting
          </button>
          <button
            onclick="sendQuickMessage('Show my recent meetings')"
            class="px-3 py-1 bg-green-100 text-green-700 rounded-full text-xs hover:bg-green-200"
          >
            ğŸ“‹ My Meetings
          </button>
          <button
            onclick="sendQuickMessage('Find team members named John')"
            class="px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs hover:bg-purple-200"
          >
            ğŸ‘¥ Find People
          </button>
          <button
            onclick="sendQuickMessage('Send message to Sarah about project update')"
            class="px-3 py-1 bg-orange-100 text-orange-700 rounded-full text-xs hover:bg-orange-200"
          >
            ğŸ’¬ Send Message
          </button>
          <button
            onclick="sendQuickMessage('Join AI agent to my latest meeting')"
            class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded-full text-xs hover:bg-indigo-200"
          >
            ğŸ¤– Join Agent
          </button>
          <button
            onclick="sendQuickMessage('Get summary of my last meeting')"
            class="px-3 py-1 bg-pink-100 text-pink-700 rounded-full text-xs hover:bg-pink-200"
          >
            ğŸ“Š Meeting Summary
          </button>
        </div>
        <form id="chat-form" class="flex items-center space-x-3">
          <input
            type="text"
            id="message-input"
            class="flex-1 block w-full px-4 py-3 bg-white border border-slate-300 rounded-xl text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:bg-slate-100"
            placeholder="Schedule a meeting, find people, or ask about your calendar..."
            autocomplete="off"
            disabled
          />
          <button
            type="submit"
            id="send-button"
            class="p-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-xl hover:from-blue-600 hover:to-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-slate-300"
            disabled
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"
              />
            </svg>
          </button>
        </form>
      </div>
    </div>

    <script>
      const ui = {
        chatContainer: document.getElementById("chat-container"),
        chatForm: document.getElementById("chat-form"),
        messageInput: document.getElementById("message-input"),
        sendButton: document.getElementById("send-button"),
        autoInsightsStatus: document.getElementById("auto-insights-status"),
      };

      const API_BASE_URL = "http://localhost:5000/api";
      const GEMINI_API_KEY = "AIzaSyBnsIjTRbrHAwKC5ko5K0dvxjp3Cwj5GoQ";
      const GEMINI_MODEL = "gemini-2.0-flash";

      // Enhanced session management
      let sessionId = Date.now();
      let conversationHistory = [];
      let lastCreatedMeeting = null;
      let autoInsightsActive = false;
      let responseVarietyTracker = new Set();
      let userMeetings = [];

      // ====================================================================
      // --- COMPREHENSIVE AGENT TOOLS ---
      // ====================================================================

      const agentTools = [
        {
          name: "create_meeting",
          description:
            "Creates a new Teams meeting with auto-insights and attendee resolution",
          parameters: {
            type: "object",
            properties: {
              subject: { type: "string", description: "Meeting title/subject" },
              description: {
                type: "string",
                description: "Meeting description",
              },
              date: {
                type: "string",
                description: "Date like 'today', 'tomorrow', 'January 15', '2025-01-15'",
              },
              time: {
                type: "string",
                description: "Time like '2pm', '14:30', '3:00 PM'",
              },
              attendees: {
                type: "array",
                items: { type: "string" },
                description: "Names or emails of attendees",
              },
              duration: {
                type: "number",
                description: "Meeting duration in minutes, default 30",
              },
              enableAutoInsights: {
                type: "boolean",
                description: "Enable auto-insights, default true",
              },
              enableChatCapture: {
                type: "boolean",
                description: "Enable chat monitoring, default true",
              },
            },
            required: ["subject", "date", "time"],
          },
        },
        {
          name: "get_meetings",
          description: "Lists user's meetings with filters and details",
          parameters: {
            type: "object",
            properties: {
              status: {
                type: "string",
                enum: ["scheduled", "in_progress", "completed", "cancelled"],
              },
              limit: {
                type: "number",
                description: "Number of meetings to show, default 10",
              },
              detailed: {
                type: "boolean",
                description: "Show detailed meeting info, default false",
              },
            },
          },
        },
        {
          name: "join_meeting_agent",
          description:
            "Join AI agent to a specific meeting for live monitoring",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "leave_meeting_agent",
          description: "Remove AI agent from meeting and generate summary",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "cancel_meeting",
          description: "Cancel a scheduled meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_details",
          description: "Get detailed information about a specific meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_summary",
          description: "Generate or retrieve meeting summary with AI insights",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
              regenerate: {
                type: "boolean",
                description: "Force regenerate summary, default false",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_analysis",
          description: "Get detailed chat analysis and insights for a meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "find_people",
          description: "Search for team members by name or role",
          parameters: {
            type: "object",
            properties: {
              searchTerm: {
                type: "string",
                description: "Name or role to search for",
              },
              limit: {
                type: "number",
                description: "Max results to return, default 10",
              },
            },
            required: ["searchTerm"],
          },
        },
        {
          name: "get_team_members",
          description: "List all team members in the organization",
          parameters: {
            type: "object",
            properties: {
              limit: {
                type: "number",
                description: "Max members to show, default 20",
              },
              includeDetails: {
                type: "boolean",
                description: "Include job titles and departments",
              },
            },
          },
        },
        {
          name: "send_message",
          description: "Send a message to a team member",
          parameters: {
            type: "object",
            properties: {
              recipient: {
                type: "string",
                description: "Name or email of recipient",
              },
              message: {
                type: "string",
                description: "Message content to send",
              },
            },
            required: ["recipient", "message"],
          },
        },
        {
          name: "resolve_users",
          description: "Resolve user names to emails using Teams directory",
          parameters: {
            type: "object",
            properties: {
              names: {
                type: "array",
                items: { type: "string" },
                description: "Array of names to resolve",
              },
            },
            required: ["names"],
          },
        },
        {
          name: "suggest_meeting_times",
          description:
            "Find optimal meeting times based on attendee availability",
          parameters: {
            type: "object",
            properties: {
              attendees: {
                type: "array",
                items: { type: "string" },
                description: "Attendee emails",
              },
              duration: {
                type: "number",
                description: "Meeting duration in minutes, default 30",
              },
            },
            required: ["attendees"],
          },
        },
        {
          name: "answer_general_question",
          description:
            "Handle general questions, greetings, and provide information",
          parameters: {
            type: "object",
            properties: {
              responseText: { type: "string", description: "Response to user" },
              responseType: {
                type: "string",
                description: "Type of response for variety tracking",
              },
              includeCapabilities: {
                type: "boolean",
                description: "Include capability overview",
              },
            },
            required: ["responseText"],
          },
        },
      ];

      // ====================================================================
      // --- ENHANCED AGENT PROMPT ---
      // ====================================================================

function getAgentPrompt(history, message) {
  const historyString = history
    .slice(-6)
    .map((turn, index) => `${turn.role}: ${turn.message}`)
    .join("\n");
  const currentDate = new Date().toLocaleDateString();
  const currentTime = new Date().toLocaleTimeString();

  return `You are Agent 365, an advanced AI meeting assistant with full Microsoft Teams integration including channel management.

**Current Context:**
- Date: ${currentDate}
- Time: ${currentTime}
- Session: ${sessionId}

**Recent Conversation:**
${historyString}

**User Request:** "${message}"

**CRITICAL MEETING CREATION RULES:**
When creating meetings, ALWAYS analyze attendees carefully:

**ATTENDEE DETECTION PATTERNS:**
- "with John" â†’ attendees: ["John"] (NAME - use create-with-names)
- "with john.doe@company.com" â†’ attendees: ["john.doe@company.com"] (EMAIL - use regular create)
- "with John Smith and sarah@company.com" â†’ attendees: ["John Smith", "sarah@company.com"] (MIXED - use create-with-names)
- "with Anusha" â†’ attendees: ["Anusha"] (NAME - use create-with-names)
- "with the team" â†’ attendees: ["team"] (GROUP - use create-with-names)

**EMAIL vs NAME DETECTION:**
- Contains "@" and no spaces = EMAIL
- Contains spaces or no "@" = NAME
- If ANY attendee is a name, use create-with-names endpoint

**MEETING CREATION EXAMPLES:**

User: "Schedule a meeting with Anusha on project design sync on 19 august 2025 10pm to 11pm"
Response: {
  "tool_name": "create_meeting",
  "parameters": {
    "subject": "project design sync",
    "description": "Meeting with Anusha about project design sync",
    "date": "19 august 2025",
    "time": "10pm",
    "attendees": ["Anusha"],
    "duration": 60,
    "enableAutoInsights": true,
    "enableChatCapture": true
  }
}

User: "Create meeting tomorrow at 2pm with john.doe@company.com"
Response: {
  "tool_name": "create_meeting",
  "parameters": {
    "subject": "Meeting",
    "date": "tomorrow",
    "time": "2pm",
    "attendees": ["john.doe@company.com"],
    "duration": 30,
    "enableAutoInsights": true
  }
}

User: "Schedule meeting with John Smith and sarah@company.com about budget review"
Response: {
  "tool_name": "create_meeting",
  "parameters": {
    "subject": "budget review",
    "date": "tomorrow",
    "time": "2pm",
    "attendees": ["John Smith", "sarah@company.com"],
    "duration": 30,
    "enableAutoInsights": true
  }
}

**MEETING EXTRACTION RULES:**
1. Extract subject from context words like "about", "on", "regarding"
2. Extract ALL attendee names/emails after "with"
3. Parse date naturally (today, tomorrow, specific dates)
4. Parse time in any format (2pm, 14:00, 10pm)
5. Calculate duration from start/end times if given
6. Always include attendees array even if empty

**OTHER TOOL RULES:**
- "Find team members named John" â†’ find_people with searchTerm: "John"
- "Show my meetings" â†’ get_meetings
- "Create channel [name] in [team]" â†’ create_channel
- "List teams" â†’ list_teams

**CRITICAL: ALWAYS extract attendees from meeting requests!**
Never leave attendees empty if names are mentioned in the user request.

Analyze the user request and respond with the appropriate tool:`;
}


      // ====================================================================
      // --- AI RESPONSE GENERATION ---
      // ====================================================================

      async function getAgentAction(message) {
        const prompt = getAgentPrompt(conversationHistory, message);
        console.log("ğŸ¤– Agent Prompt:", prompt);

        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        try {
          const response = await fetch(API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{ parts: [{ text: prompt }] }],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 1000,
                topP: 0.9,
                topK: 40,
              },
            }),
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Gemini API error: ${errorData.error.message}`);
          }

          const data = await response.json();
          const rawText = data.candidates[0].content.parts[0].text;
          console.log("ğŸ¤– Raw AI Response:", rawText);

          // IMPROVED JSON PARSING - Fix the malformed JSON issue
          let jsonString = rawText.replace(/```json|```/g, "").trim();

          // Try to find JSON within the response if it's wrapped in other text
          const jsonMatch = jsonString.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            jsonString = jsonMatch[0];
          }

          let action;
          try {
            action = JSON.parse(jsonString);
          } catch (parseError) {
            console.error("JSON Parse Error:", parseError);
            console.error("Failed JSON String:", jsonString);

            // Fallback: create a general response action
            return {
              tool_name: "answer_general_question",
              parameters: {
                responseText:
                  "I understand you'd like help with that. Let me assist you with your meeting and collaboration needs.",
                responseType: "fallback",
              },
            };
          }

          console.log("ğŸ¤– Parsed Action:", action);
          return action;
        } catch (error) {
          console.error("AI Action Error:", error);
          return {
            tool_name: "answer_general_question",
            parameters: {
              responseText: `I'm having trouble processing that request. Please try rephrasing your request or use one of the quick action buttons.`,
              responseType: "error",
            },
          };
        }
      }

      // ====================================================================
      // --- MESSAGE HANDLING ---
      // ====================================================================

      async function handleUserMessage(message) {
        addMessage(message, "user");
        conversationHistory.push({
          role: "user",
          message: message,
          timestamp: Date.now(),
        });

        showLoading(true);

        const action = await getAgentAction(message);
        if (!action || !action.tool_name) {
          addMessage("I'm not sure how to help with that.", "bot");
          showLoading(false);
          return;
        }

        let agentResponseText = "";
        try {
          switch (action.tool_name) {
            case "create_meeting":
              agentResponseText = await handleCreateMeeting(action.parameters);
              break;
            case "get_meetings":
              agentResponseText = await handleGetMeetings(action.parameters);
              break;
            case "join_meeting_agent":
              agentResponseText = await handleJoinMeetingAgent(
                action.parameters
              );
              break;
            case "leave_meeting_agent":
              agentResponseText = await handleLeaveMeetingAgent(
                action.parameters
              );
              break;
            case "cancel_meeting":
              agentResponseText = await handleCancelMeeting(action.parameters);
              break;
            case "get_meeting_details":
              agentResponseText = await handleGetMeetingDetails(
                action.parameters
              );
              break;
            case "get_meeting_summary":
              agentResponseText = await handleGetMeetingSummary(
                action.parameters
              );
              break;
            case "get_meeting_analysis":
              agentResponseText = await handleGetMeetingAnalysis(
                action.parameters
              );
              break;
            case "find_people":
              agentResponseText = await handleFindPeople(action.parameters);
              break;
            case "get_team_members":
              agentResponseText = await handleGetTeamMembers(action.parameters);
              break;
            case "send_message":
              agentResponseText = await handleSendMessage(action.parameters);
              break;
            case "resolve_users":
              agentResponseText = await handleResolveUsers(action.parameters);
              break;
            case "suggest_meeting_times":
              agentResponseText = await handleSuggestMeetingTimes(
                action.parameters
              );
              break;
            case "answer_general_question":
              agentResponseText =
                action.parameters.responseText ||
                "Hello! How can I help you today?";
              if (action.parameters.includeCapabilities) {
                agentResponseText += "\n\n" + getCapabilitiesOverview();
              }
              addMessage(agentResponseText, "bot");
              // Don't return here, let it continue to update conversation history
              break;
            default:
              agentResponseText = `Unknown command: ${action.tool_name}`;
              addMessage(agentResponseText, "bot");
          }
        } catch (error) {
          console.error("Tool execution error:", error);
          agentResponseText = `Sorry, I encountered an error: ${error.message}`;
          addMessage(agentResponseText, "bot");
        }

        conversationHistory.push({
          role: "agent",
          message: agentResponseText,
          timestamp: Date.now(),
          tool_used: action.tool_name,
        });

        if (conversationHistory.length > 10) {
          conversationHistory = conversationHistory.slice(-10);
        }
        showLoading(false);
      }

      // ====================================================================
      // --- TOOL IMPLEMENTATIONS ---
      // ====================================================================

async function handleCreateMeeting(params) {
  try {
    console.log("ğŸ“… Creating meeting with params:", params);

    // ENHANCED VALIDATION with better defaults
    if (!params.subject) {
      // Try to extract subject from description or use default
      params.subject = params.description || "Meeting";
    }

    if (!params.date) {
      // Default to tomorrow if no date specified
      params.date = "tomorrow";
      console.log("âš ï¸ No date specified, defaulting to tomorrow");
    }

    if (!params.time) {
      // Default to next hour if no time specified
      const nextHour = new Date();
      nextHour.setHours(nextHour.getHours() + 1, 0, 0, 0);
      params.time = nextHour.toLocaleTimeString("en-US", {
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      });
      console.log(`âš ï¸ No time specified, defaulting to ${params.time}`);
    }

    console.log("ğŸ“… Final params after validation:", params);

    // Enhanced date/time parsing
    const startTime = parseDateTime(params.date, params.time);
    console.log("ğŸ• Parsed start time:", startTime);

    const endTime = new Date(
      new Date(startTime).getTime() + (params.duration || 30) * 60000
    ).toISOString();

    const attendees = params.attendees || [];

    // CRITICAL FIX: Improved email detection
    const isEmail = (str) => {
      // Must contain @ AND have valid email format AND no spaces before @
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(str.trim());
    };

    // CRITICAL FIX: Better name detection
    const isName = (str) => {
      const trimmed = str.trim();
      // It's a name if it doesn't match email format
      return !isEmail(trimmed);
    };

    // Separate names from emails with improved logic
    const attendeeEmails = attendees.filter(attendee => isEmail(attendee));
    const attendeeNames = attendees.filter(attendee => isName(attendee));

    console.log("ğŸ‘¥ IMPROVED Attendee analysis:", {
      total: attendees.length,
      rawAttendees: attendees,
      emails: attendeeEmails,
      names: attendeeNames,
      hasNames: attendeeNames.length > 0,
      willUseNameResolution: attendeeNames.length > 0
    });

    let payload;
    let endpoint;

    // CRITICAL FIX: Always use name resolution if ANY attendee is detected as a name
    if (attendeeNames.length > 0) {
      // Use create-with-names endpoint for name resolution
      console.log("ğŸ”„ Using name-based meeting creation for attendees:", attendeeNames);
      endpoint = `${API_BASE_URL}/meetings/create-with-names`;
      payload = {
        subject: params.subject,
        description: params.description || `${params.subject} - Created with AI assistance`,
        startTime,
        endTime,
        attendeeNames: attendeeNames,
        attendeeEmails: attendeeEmails,
        autoJoinAgent: params.enableAutoInsights !== false,
        enableChatCapture: params.enableChatCapture !== false,
      };
    } else if (attendeeEmails.length > 0) {
      // Use regular create endpoint for emails only
      console.log("ğŸ“§ Using email-based meeting creation for emails:", attendeeEmails);
      endpoint = `${API_BASE_URL}/meetings/create`;
      payload = {
        subject: params.subject,
        description: params.description || `${params.subject} - Created with AI assistance`,
        startTime,
        endTime,
        attendees: attendeeEmails,
        autoJoinAgent: params.enableAutoInsights !== false,
        enableChatCapture: params.enableChatCapture !== false,
      };
    } else {
      // No attendees - use regular create endpoint
      console.log("ğŸ‘¤ Creating meeting with no attendees");
      endpoint = `${API_BASE_URL}/meetings/create`;
      payload = {
        subject: params.subject,
        description: params.description || `${params.subject} - Created with AI assistance`,
        startTime,
        endTime,
        attendees: [],
        autoJoinAgent: params.enableAutoInsights !== false,
        enableChatCapture: params.enableChatCapture !== false,
      };
    }

    console.log("ğŸ“¤ Sending payload to:", endpoint);
    console.log("ğŸ“¦ Payload:", payload);

    const response = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    const data = await response.json();
    console.log("ğŸ“¨ Response:", data);

    if (!response.ok) {
      throw new Error(
        data.details || data.error || "Failed to create meeting"
      );
    }

    lastCreatedMeeting = data.meeting;
    userMeetings.unshift(data.meeting);

    if (params.enableAutoInsights !== false) {
      showAutoInsightsStatus(true);
    }

    const meetingCard = createMeetingCard(
      data.meeting,
      data.userResolution
    );
    addMessage(meetingCard, "bot", "card");

    let successMessage = `âœ… Meeting "${
      params.subject
    }" created successfully!\nğŸ• Scheduled for: ${new Date(
      startTime
    ).toLocaleString()}\nğŸ¤– Auto-insights: ${
      params.enableAutoInsights !== false ? "ENABLED" : "DISABLED"
    }`;

    if (data.userResolution && attendeeNames.length > 0) {
      successMessage += `\nğŸ‘¥ Name Resolution: ${data.userResolution.usersResolved}/${data.userResolution.namesRequested} names resolved from Teams directory`;
      successMessage += `\nğŸ“§ Final attendees: ${
        data.meeting.attendees?.length || 0
      } total`;
    } else {
      successMessage += `\nğŸ‘¥ Attendees: ${
        data.meeting.attendees?.length || 0
      }`;
    }

    return successMessage;
  } catch (error) {
    console.error("âŒ Meeting creation error:", error);
    const msg = `âŒ Failed to create meeting: ${error.message}`;
    addMessage(msg, "bot");
    return msg;
  }
}



      async function handleGetMeetings(params) {
        try {
          let url = `${API_BASE_URL}/meetings?limit=${params.limit || 10}`;
          if (params.status) {
            url += `&status=${params.status}`;
          }

          const response = await fetch(url);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meetings");
          }

          userMeetings = data.meetings; // Cache for other operations

          if (data.meetings.length === 0) {
            const msg = "ğŸ“… No meetings found. Would you like to schedule one?";
            addMessage(msg, "bot");
            return msg;
          }

          if (params.detailed) {
            // Show detailed meeting cards
            data.meetings.forEach((meeting) => {
              const card = createMeetingCard(meeting);
              addMessage(card, "bot", "card");
            });
            return `ğŸ“‹ Showing ${data.meetings.length} detailed meeting(s)`;
          } else {
            // Show compact list
            let resultMsg = `ğŸ“‹ **Your Meetings** (${data.meetings.length} found):\n\n`;
            data.meetings.forEach((meeting, index) => {
              const date = new Date(meeting.startTime).toLocaleString();
              const status = getStatusBadge(meeting.status);
              const insights = meeting.agentAttended ? "ğŸ¤–" : "ğŸ‘¤";

              resultMsg += `${index + 1}. **${meeting.subject}**\n`;
              resultMsg += `   â° ${date}\n`;
              resultMsg += `   ${status} ${insights} ${
                meeting.attendees?.length || 0
              } attendees\n\n`;
            });

            addMessage(resultMsg, "bot");
            return resultMsg;
          }
        } catch (error) {
          const msg = `âŒ Failed to get meetings: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleJoinMeetingAgent(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/join-agent`,
            {
              method: "POST",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to join meeting");
          }

          showAutoInsightsStatus(true);

          const msg =
            `ğŸ¤– **AI Agent Joined Successfully!**\n\n` +
            `ğŸ“‹ Meeting: "${meeting.subject}"\n` +
            `âœ… Auto-insights activated\n` +
            `ğŸ’¬ Chat monitoring started\n` +
            `ğŸ“Š Real-time analytics enabled\n` +
            `ğŸ“§ Live updates will be sent to attendees\n\n` +
            `The AI agent is now visible to all participants and ready to provide insights!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to join meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleLeaveMeetingAgent(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/leave-agent`,
            {
              method: "POST",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to leave meeting");
          }

          showAutoInsightsStatus(false);

          const msg =
            `ğŸ **AI Agent Left Meeting**\n\n` +
            `ğŸ“‹ Meeting: "${meeting.subject}"\n` +
            `âœ… Session completed\n` +
            `ğŸ“Š Final summary generated\n` +
            `ğŸ“§ Comprehensive report sent to all attendees\n` +
            `ğŸ’¾ All insights and analytics saved\n\n` +
            `Check your email for the detailed meeting summary!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to leave meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleCancelMeeting(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}`,
            {
              method: "DELETE",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to cancel meeting");
          }

          // Update local cache
          userMeetings = userMeetings.filter((m) => m.id !== meeting.id);

          const msg =
            `ğŸ—‘ï¸ **Meeting Cancelled Successfully**\n\n` +
            `ğŸ“‹ Meeting: "${meeting.subject}"\n` +
            `â° Was scheduled for: ${new Date(
              meeting.startTime
            ).toLocaleString()}\n` +
            `ğŸ‘¥ ${
              meeting.attendees?.length || 0
            } attendees will be notified\n` +
            `âœ… Calendar has been updated\n\n` +
            `All participants will receive cancellation notifications.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to cancel meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingDetails(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/status`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting details");
          }

          const detailCard = createDetailedMeetingCard(
            data.meeting,
            data.timing,
            data.agentStatus
          );
          addMessage(detailCard, "bot", "card");

          return `ğŸ“‹ Detailed information for "${meeting.subject}" displayed above.`;
        } catch (error) {
          const msg = `âŒ Failed to get meeting details: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingSummary(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          let url = `${API_BASE_URL}/meetings/${meeting.id}/summary`;
          if (params.regenerate) {
            url += `?regenerate=true`;
          }

          const response = await fetch(url);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting summary");
          }

          const summary = data.summary;
          let msg = `ğŸ“‹ **AI-Generated Meeting Summary**\n\n`;
          msg += `ğŸ¢ **Meeting:** ${meeting.subject}\n`;
          msg += `ğŸ“… **Date:** ${new Date(
            meeting.startTime
          ).toLocaleString()}\n\n`;

          if (summary.executiveSummary) {
            msg += `ğŸ“ **Executive Summary:**\n${summary.executiveSummary}\n\n`;
          }

          if (summary.actionItems && summary.actionItems.length > 0) {
            msg += `âœ… **Action Items (${summary.actionItems.length}):**\n`;
            summary.actionItems.forEach((item, index) => {
              msg += `${index + 1}. ${item.task}\n`;
              if (item.assignee) msg += `   ğŸ‘¤ Assigned to: ${item.assignee}\n`;
              if (item.deadline) msg += `   ğŸ“… Due: ${item.deadline}\n`;
            });
            msg += `\n`;
          }

          if (summary.metrics) {
            msg += `ğŸ“Š **Meeting Metrics:**\n`;
            msg += `â€¢ Messages: ${summary.metrics.totalMessages || 0}\n`;
            msg += `â€¢ Questions: ${summary.metrics.questionsAsked || 0}\n`;
            msg += `â€¢ Decisions: ${summary.metrics.decisionsTracked || 0}\n\n`;
          }

          if (summary.qualityScores) {
            msg += `ğŸ¯ **Quality Score:** ${summary.qualityScores.overall}/10\n\n`;
          }

          msg += `ğŸ¤– Generated with AI auto-insights`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to get meeting summary: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingAnalysis(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/chat-analysis`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting analysis");
          }

          const analysis = data.analysis;
          let msg = `ğŸ“Š **Meeting Chat Analysis**\n\n`;
          msg += `ğŸ¢ **Meeting:** ${meeting.subject}\n`;
          msg += `ğŸ’¬ **Total Messages:** ${analysis.totalMessages}\n\n`;

          if (analysis.categorizedCounts) {
            msg += `ğŸ“ˆ **Message Categories:**\n`;
            msg += `â€¢ â“ Questions: ${analysis.categorizedCounts.questions}\n`;
            msg += `â€¢ âœ… Action Items: ${analysis.categorizedCounts.actionItems}\n`;
            msg += `â€¢ ğŸ¯ Decisions: ${analysis.categorizedCounts.decisions}\n`;
            msg += `â€¢ ğŸ“ Shared Resources: ${analysis.categorizedCounts.sharedResources}\n\n`;
          }

          if (analysis.participantAnalysis) {
            msg += `ğŸ‘¥ **Top Participants:**\n`;
            Object.entries(analysis.participantAnalysis)
              .sort(([, a], [, b]) => b.messageCount - a.messageCount)
              .slice(0, 3)
              .forEach(([name, stats]) => {
                msg += `â€¢ **${name}**: ${stats.messageCount} messages\n`;
              });
            msg += `\n`;
          }

          if (analysis.keyInsights) {
            msg += `ğŸ’¡ **Key Insights:**\n`;
            if (analysis.keyInsights.mostActiveParticipant) {
              msg += `ğŸ† Most Active: ${analysis.keyInsights.mostActiveParticipant}\n`;
            }
          }

          msg += `\nğŸ¤– Analysis powered by auto-insights AI`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to get meeting analysis: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleFindPeople(params) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/users/search?q=${encodeURIComponent(
              params.searchTerm
            )}&limit=${params.limit || 10}`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to search people");
          }

          if (data.users.length === 0) {
            const msg = `ğŸ” No team members found matching "${params.searchTerm}". Try a different search term.`;
            addMessage(msg, "bot");
            return msg;
          }

          let msg = `ğŸ‘¥ **Found ${data.users.length} team member(s) for "${params.searchTerm}":**\n\n`;
          data.users.forEach((user, index) => {
            msg += `${index + 1}. **${user.name}**\n`;
            msg += `   ğŸ“§ ${user.email}\n`;
            if (user.jobTitle) msg += `   ğŸ’¼ ${user.jobTitle}\n`;
            if (user.department) msg += `   ğŸ¢ ${user.department}\n`;
            msg += `\n`;
          });

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to find people: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetTeamMembers(params) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/users?limit=${params.limit || 20}`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get team members");
          }

          if (data.users.length === 0) {
            const msg = "ğŸ‘¥ No team members found in the directory.";
            addMessage(msg, "bot");
            return msg;
          }

          let msg = `ğŸ‘¥ **Team Directory** (${data.total} total members):\n\n`;
          data.users.slice(0, 15).forEach((user, index) => {
            msg += `${index + 1}. **${user.name}**\n`;
            msg += `   ğŸ“§ ${user.email}\n`;
            if (params.includeDetails) {
              if (user.jobTitle) msg += `   ğŸ’¼ ${user.jobTitle}\n`;
              if (user.department) msg += `   ğŸ¢ ${user.department}\n`;
            }
            msg += `\n`;
          });

          if (data.total > 15) {
            msg += `... and ${data.total - 15} more members\n\n`;
          }

          msg += `ğŸ’¡ Use "find people named [name]" to search for specific team members.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to get team members: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleSendMessage(params) {
        try {
          const response = await fetch(`${API_BASE_URL}/users/resolve`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ names: [params.recipient] }),
          });

          const userData = await response.json();
          if (!response.ok || userData.resolvedUsers.length === 0) {
            throw new Error(`Could not find user: ${params.recipient}`);
          }

          const resolvedUser = userData.resolvedUsers[0];

          // In a real implementation, you would send the message via Teams/email
          // For now, we'll simulate the message sending
          const msg =
            `âœ… **Message Sent Successfully!**\n\n` +
            `ğŸ‘¤ **To:** ${resolvedUser.name}\n` +
            `ğŸ“§ **Email:** ${resolvedUser.email}\n` +
            `ğŸ’¬ **Message:** "${params.message}"\n\n` +
            `ğŸ“¬ Your message has been delivered and they should receive it shortly.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to send message: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleResolveUsers(params) {
        try {
          const response = await fetch(`${API_BASE_URL}/users/resolve`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ names: params.names }),
          });

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to resolve users");
          }

          let msg = `ğŸ” **User Resolution Results:**\n\n`;
          msg += `ğŸ“Š Success Rate: ${data.summary?.successRate || "N/A"}\n`;
          msg += `âœ… Found: ${data.resolvedUsers.length}/${params.names.length}\n\n`;

          if (data.resolvedUsers.length > 0) {
            msg += `**Resolved Users:**\n`;
            data.resolvedUsers.forEach((user, index) => {
              msg += `${index + 1}. **${user.name}** â†’ ${user.email}\n`;
            });
          }

          if (data.resolvedUsers.length < params.names.length) {
            const notFound = params.names.filter(
              (name) =>
                !data.resolvedUsers.some((user) =>
                  user.name.toLowerCase().includes(name.toLowerCase())
                )
            );
            msg += `\nâŒ **Not Found:** ${notFound.join(", ")}`;
          }

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to resolve users: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleSuggestMeetingTimes(params) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/meetings/suggest-times`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                attendees: params.attendees,
                duration: params.duration || 30,
              }),
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting suggestions");
          }

          let msg = `ğŸ• **Optimal Meeting Times**\n\n`;
          msg += `ğŸ‘¥ Checked availability for ${params.attendees.length} attendees\n`;
          msg += `â±ï¸ Duration: ${params.duration || 30} minutes\n\n`;

          if (data.suggestions && data.suggestions.length > 0) {
            msg += `**ğŸ“… Suggested Times:**\n`;
            data.suggestions.slice(0, 5).forEach((suggestion, index) => {
              const startTime = new Date(suggestion.startTime).toLocaleString();
              const endTime = new Date(suggestion.endTime).toLocaleString();
              msg += `${index + 1}. ${startTime} - ${endTime}\n`;
              if (suggestion.confidence) {
                msg += `   ğŸ“Š Confidence: ${Math.round(
                  suggestion.confidence * 100
                )}%\n`;
              }
            });
          } else {
            msg += `âŒ No optimal times found. Try different attendees or duration.`;
          }

          msg += `\n\nğŸ’¡ Use these times when creating your meeting for best attendance!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `âŒ Failed to suggest meeting times: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      // ====================================================================
      // --- UTILITY FUNCTIONS ---
      // ====================================================================

      async function findMeetingByIdentifier(identifier) {
        // First try to get fresh meeting list
        try {
          const response = await fetch(`${API_BASE_URL}/meetings?limit=20`);
          const data = await response.json();
          if (response.ok) {
            userMeetings = data.meetings;
          }
        } catch (error) {
          console.warn("Could not refresh meeting list:", error);
        }

        if (
          identifier.toLowerCase() === "latest" ||
          identifier.toLowerCase() === "recent"
        ) {
          if (userMeetings.length === 0) {
            throw new Error("No meetings found. Create a meeting first.");
          }
          return userMeetings[0]; // Most recent
        }

        // Try to find by ID first
        let meeting = userMeetings.find(
          (m) => m.id === identifier || m.meetingId === identifier
        );

        // If not found, try by subject (partial match)
        if (!meeting) {
          meeting = userMeetings.find((m) =>
            m.subject.toLowerCase().includes(identifier.toLowerCase())
          );
        }

        if (!meeting) {
          throw new Error(
            `Meeting not found: "${identifier}". Try using the exact meeting subject or "latest".`
          );
        }

        return meeting;
      }

      // ====================================================================
      // --- COMPREHENSIVE DATE/TIME PARSING FUNCTION ---
      // ====================================================================

    function parseDateTime(dateStr, timeStr) {
  console.log("ğŸ• Parsing date/time:", { dateStr, timeStr });

  const now = new Date();
  let meetingDate = new Date(now);

  // ============ ENHANCED DATE PARSING ============
  if (dateStr) {
    const dateLower = dateStr.toLowerCase().trim();
    let dateResolved = false;

    // Relative dates
    if (dateLower === "today") {
      meetingDate = new Date(now);
      dateResolved = true;
    } else if (dateLower === "tomorrow") {
      meetingDate = new Date(now);
      meetingDate.setDate(now.getDate() + 1);
      dateResolved = true;
    } else if (dateLower.includes("next week")) {
      meetingDate = new Date(now);
      meetingDate.setDate(now.getDate() + 7);
      dateResolved = true;
    }

    // Weekdays
    const weekdays = {
      monday: 1,
      tuesday: 2,
      wednesday: 3,
      thursday: 4,
      friday: 5,
      saturday: 6,
      sunday: 0,
    };

    for (const [day, dayNum] of Object.entries(weekdays)) {
      if (dateLower.includes(day)) {
        meetingDate = getNextWeekday(now, dayNum);
        dateResolved = true;
        break;
      }
    }

    // Month names parsing (comprehensive)
    if (!dateResolved) {
      const monthNames = {
        january: 0, jan: 0, february: 1, feb: 1, march: 2, mar: 2,
        april: 3, apr: 3, may: 4, june: 5, jun: 5, july: 6, jul: 6,
        august: 7, aug: 7, september: 8, sep: 8, october: 9, oct: 9,
        november: 10, nov: 10, december: 11, dec: 11,
      };

      // Patterns: "15 august", "august 15", "15th august", "aug 15"
      const patterns = [
        /(\d{1,2})(?:st|nd|rd|th)?\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        /(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})(?:st|nd|rd|th)?/i,
      ];

      for (const pattern of patterns) {
        const match = dateLower.match(pattern);
        if (match) {
          let day, monthName;
          if (/\d/.test(match[1])) {
            day = parseInt(match[1]);
            monthName = match[2].toLowerCase();
          } else {
            day = parseInt(match[2]);
            monthName = match[1].toLowerCase();
          }

          const monthIndex = monthNames[monthName];
          if (monthIndex !== undefined && day >= 1 && day <= 31) {
            meetingDate = new Date(now.getFullYear(), monthIndex, day);

            // If date is in the past, move to next year
            if (meetingDate < new Date(now.getFullYear(), now.getMonth(), now.getDate())) {
              meetingDate.setFullYear(now.getFullYear() + 1);
            }
            dateResolved = true;
            break;
          }
        }
      }
    }

    // Numeric date patterns: "15/8", "8/15", "15-8", "2025-08-15"
    if (!dateResolved) {
      const numericPatterns = [
        /(\d{4})-(\d{1,2})-(\d{1,2})/, // YYYY-MM-DD
        /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, // DD/MM/YYYY or MM/DD/YYYY
        /(\d{1,2})[\/\-](\d{1,2})/, // DD/MM or MM/DD
      ];

      for (const pattern of numericPatterns) {
        const match = dateStr.match(pattern);
        if (match) {
          let year, month, day;

          if (match[0].includes(match[1]) && match[1].length === 4) {
            // YYYY-MM-DD format
            year = parseInt(match[1]);
            month = parseInt(match[2]) - 1;
            day = parseInt(match[3]);
          } else if (match[3]) {
            // With year
            year = parseInt(match[3]);
            day = parseInt(match[1]);
            month = parseInt(match[2]) - 1;
          } else {
            // Without year - assume current year
            year = now.getFullYear();
            const num1 = parseInt(match[1]);
            const num2 = parseInt(match[2]);

            if (num1 > 12) {
              day = num1;
              month = num2 - 1;
            } else if (num2 > 12) {
              day = num2;
              month = num1 - 1;
            } else {
              // Both <= 12, assume DD/MM
              day = num1;
              month = num2 - 1;
            }
          }

          meetingDate = new Date(year, month, day);
          if (!isNaN(meetingDate.getTime())) {
            if (meetingDate < new Date(now.getFullYear(), now.getMonth(), now.getDate())) {
              meetingDate.setFullYear(now.getFullYear() + 1);
            }
            dateResolved = true;
            break;
          }
        }
      }
    }

    // Fallback: try native Date parsing
    if (!dateResolved) {
      const fallbackFormats = [
        `${dateStr} ${now.getFullYear()}`,
        `${now.getFullYear()}-${dateStr}`,
        dateStr,
      ];

      for (const format of fallbackFormats) {
        const testDate = new Date(format);
        if (!isNaN(testDate.getTime()) && testDate.getFullYear() >= now.getFullYear()) {
          meetingDate = testDate;
          dateResolved = true;
          break;
        }
      }
    }
  }

  // ============ ENHANCED TIME PARSING ============
  if (timeStr) {
    const timeLower = timeStr.toLowerCase().trim();
    console.log("ğŸ• Parsing time:", timeLower);

    let hours = null;
    let minutes = 0;

    // Comprehensive time patterns
    const timePatterns = [
      // 12-hour format with AM/PM
      /(\d{1,2}):(\d{2})\s*(am|pm)/i, // 2:30pm, 10:15am
      /(\d{1,2})\s*(am|pm)/i, // 2pm, 10am
      /(\d{1,2})\.(\d{2})\s*(am|pm)/i, // 2.30pm

      // 24-hour format
      /(\d{1,2}):(\d{2})$/, // 14:30, 02:15
      /(\d{1,2})\.(\d{2})$/, // 14.30, 02.15
      /(\d{1,2})h(\d{2})/i, // 14h30, 2h15
      /(\d{1,2})h$/i, // 14h, 2h

      // Simple hour formats
      /^(\d{1,2})$/, // 14, 2 (assume 24h if >12, otherwise next occurrence)
    ];

    for (const pattern of timePatterns) {
      const match = timeLower.match(pattern);
      if (match) {
        hours = parseInt(match[1], 10);
        minutes = match[2] ? parseInt(match[2], 10) : 0;

        // Handle AM/PM conversion
        if (match[3]) {
          const period = match[3].toLowerCase();
          if (period === "pm" && hours < 12) {
            hours += 12;
          } else if (period === "am" && hours === 12) {
            hours = 0;
          }
        } else if (hours <= 12 && !timeLower.includes(":") && !timeLower.includes(".") && !timeLower.includes("h")) {
          // For simple hour format, assume PM if it's a reasonable time
          if (hours >= 8 && hours <= 11) {
            const currentHour = now.getHours();
            if (currentHour >= 12) {
              hours += 12; // Assume PM if it's afternoon
            }
          }
        }

        // Validate time
        if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
          break;
        } else {
          hours = null; // Invalid time, continue to next pattern
        }
      }
    }

    // Special cases for common time expressions
    if (hours === null) {
      const specialTimes = {
        morning: [9, 0],
        noon: [12, 0],
        afternoon: [14, 0],
        evening: [18, 0],
        night: [20, 0],
        midnight: [0, 0],
      };

      for (const [timeWord, [h, m]] of Object.entries(specialTimes)) {
        if (timeLower.includes(timeWord)) {
          hours = h;
          minutes = m;
          break;
        }
      }
    }

    // Apply time to meeting date
    if (hours !== null) {
      meetingDate.setHours(hours, minutes, 0, 0);
      console.log("ğŸ• Set time to:", hours, ":", minutes);
    } else {
      console.warn("âš ï¸ Could not parse time:", timeStr);
      // Default to next hour
      const nextHour = new Date(now.getTime() + 3600000);
      meetingDate.setHours(nextHour.getHours(), 0, 0, 0);
    }
  } else {
    // No time specified - default to next reasonable hour
    const nextHour = new Date(now.getTime() + 3600000);
    meetingDate.setHours(nextHour.getHours(), 0, 0, 0);
  }

  // ============ IMPROVED FINAL VALIDATION ============
  // Check if the meeting is in the past
  if (meetingDate.getTime() <= now.getTime()) {
    // If it's today and time has passed, move to next reasonable time slot
    if (dateStr && (dateStr.toLowerCase() === "today" || !dateStr)) {
      // For "today" or no date specified, schedule for next available hour
      const minFutureTime = new Date(now.getTime() + (15 * 60 * 1000)); // 15 minutes from now minimum
      
      if (timeStr) {
        // Time was specified but is in the past today
        // Keep the same time but move to tomorrow
        meetingDate.setDate(meetingDate.getDate() + 1);
        console.log("âš ï¸ Specified time is in the past, moving to same time tomorrow");
      } else {
        // No time specified, use next reasonable hour
        meetingDate = new Date(Math.max(minFutureTime.getTime(), now.getTime() + 3600000));
        console.log("âš ï¸ No time specified, using next available hour");
      }
    } else if (dateStr && timeStr) {
      // Both date and time specified but in past - this should be rare
      // Keep the date but ensure it's in the future
      const originalDate = new Date(meetingDate);
      while (meetingDate.getTime() <= now.getTime()) {
        meetingDate.setDate(meetingDate.getDate() + 1);
      }
      console.log(`âš ï¸ Date/time combination was in past, moved from ${originalDate.toLocaleString()} to ${meetingDate.toLocaleString()}`);
    } else {
      // Fallback: add 1 hour to current time
      meetingDate = new Date(now.getTime() + 3600000);
      console.log("âš ï¸ Using fallback: 1 hour from now");
    }
  }

  // Final safety check: ensure at least 5 minutes in the future
  const minTime = new Date(now.getTime() + (5 * 60 * 1000)); // 5 minutes from now
  if (meetingDate.getTime() < minTime.getTime()) {
    meetingDate = minTime;
    console.log("âš ï¸ Adjusted to minimum 5 minutes in the future");
  }

  const result = meetingDate.toISOString();
  console.log("ğŸ• Final parsed datetime:", result, "Local:", meetingDate.toLocaleString());
  return result;
}



      // Helper function to get next occurrence of a weekday
      function getNextWeekday(date, targetDay) {
        const result = new Date(date);
        const currentDay = result.getDay();
        let daysToAdd = targetDay - currentDay;
        
        if (daysToAdd <= 0) {
          daysToAdd += 7; // Next week
        }
        
        result.setDate(result.getDate() + daysToAdd);
        return result;
      }

      function getStatusBadge(status) {
        const badges = {
          scheduled: "ğŸ“… Scheduled",
          in_progress: "ğŸŸ¢ In Progress",
          completed: "âœ… Completed",
          cancelled: "âŒ Cancelled",
        };
        return badges[status] || "â” Unknown";
      }

      function getCapabilitiesOverview() {
        return `**ğŸ¤– My Capabilities:**

**ğŸ“… Meeting Management:**
â€¢ Schedule Teams meetings with auto-insights
â€¢ View, cancel, and manage your meetings
â€¢ Get detailed meeting information and status

**ğŸ¤– AI Agent Features:**
â€¢ Join meetings for live monitoring and insights
â€¢ Generate comprehensive meeting summaries
â€¢ Analyze meeting chat and participant engagement

**ğŸ‘¥ Team Collaboration:**
â€¢ Find and search team members
â€¢ Send messages to colleagues
â€¢ Resolve names to email addresses

**ğŸ’¡ Smart Features:**
â€¢ Suggest optimal meeting times
â€¢ Auto-insights with real-time notifications
â€¢ Meeting analytics and quality scoring

Try commands like:
â€¢ "Schedule a meeting tomorrow at 2pm with John"
â€¢ "Show my recent meetings"
â€¢ "Join AI agent to my latest meeting"
â€¢ "Find team members named Sarah"`;
      }

      // ====================================================================
      // --- UI COMPONENTS ---
      // ====================================================================

      function createMeetingCard(meeting, userResolution = null) {
        const attendeesText = userResolution
          ? `${userResolution.usersResolved}/${userResolution.namesRequested} resolved`
          : `${meeting.attendees?.length || 0} attendees`;

        const insightsStatus = meeting.agentAttended
          ? "âœ… ENABLED"
          : "âš ï¸ DISABLED";
        const startTime = new Date(meeting.startTime).toLocaleString();

        return {
          type: "AdaptiveCard",
          version: "1.4",
          body: [
            {
              type: "TextBlock",
              text: "ğŸ“… Meeting Created Successfully!",
              weight: "Bolder",
              size: "Medium",
              color: "Good",
            },
            {
              type: "TextBlock",
              text: meeting.subject,
              weight: "Bolder",
              size: "Large",
              wrap: true,
            },
            {
              type: "TextBlock",
              text: `ğŸ• ${startTime}`,
              spacing: "Small",
              wrap: true,
            },
            {
              type: "FactSet",
              spacing: "Medium",
              facts: [
                { title: "ğŸ‘¥ Attendees:", value: attendeesText },
                { title: "ğŸ¤– Auto-Insights:", value: insightsStatus },
                { title: "ğŸ“Š Status:", value: getStatusBadge(meeting.status) },
                { title: "ğŸ”— Meeting Type:", value: "Microsoft Teams" },
              ],
            },
          ],
          actions: [
            {
              type: "Action.OpenUrl",
              title: "ğŸ”— Join Meeting",
              url: meeting.joinUrl || "#",
              style: "positive",
            },
            {
              type: "Action.OpenUrl",
              title: "ğŸ“… View in Calendar",
              url: meeting.webUrl || "#",
            },
          ],
        };
      }

      function createDetailedMeetingCard(meeting, timing, agentStatus) {
        return {
          type: "AdaptiveCard",
          version: "1.4",
          body: [
            {
              type: "TextBlock",
              text: "ğŸ“‹ Meeting Details",
              weight: "Bolder",
              size: "Medium",
              color: "Accent",
            },
            {
              type: "TextBlock",
              text: meeting.subject,
              weight: "Bolder",
              size: "Large",
              wrap: true,
            },
            {
              type: "FactSet",
              spacing: "Medium",
              facts: [
                {
                  title: "ğŸ“… Start Time:",
                  value: new Date(meeting.startTime).toLocaleString(),
                },
                {
                  title: "â° End Time:",
                  value: new Date(meeting.endTime).toLocaleString(),
                },
                { title: "ğŸ“Š Status:", value: getStatusBadge(meeting.status) },
                {
                  title: "ğŸ‘¥ Attendees:",
                  value: `${meeting.attendees?.length || 0}`,
                },
                {
                  title: "ğŸ¤– AI Agent:",
                  value: agentStatus.isAttending ? "Active" : "Inactive",
                },
                {
                  title: "â±ï¸ Duration:",
                  value: `${timing.meetingDuration} minutes`,
                },
              ],
            },
            {
              type: "TextBlock",
              text: timing.hasStarted
                ? timing.hasEnded
                  ? "âœ… Meeting completed"
                  : "ğŸŸ¢ Meeting in progress"
                : `â³ Starts in ${Math.abs(timing.minutesUntilStart)} minutes`,
              spacing: "Medium",
              wrap: true,
              color: timing.hasStarted
                ? timing.hasEnded
                  ? "Good"
                  : "Attention"
                : "Default",
            },
          ],
          actions:
            meeting.status === "scheduled"
              ? [
                  {
                    type: "Action.OpenUrl",
                    title: "ğŸ”— Join Meeting",
                    url: meeting.joinUrl || "#",
                    style: "positive",
                  },
                ]
              : [],
        };
      }

      function showAutoInsightsStatus(active) {
        autoInsightsActive = active;
        if (active) {
          ui.autoInsightsStatus.classList.add("auto-insights-active");
          ui.autoInsightsStatus.textContent = "ğŸ¤– Auto-Insights Active";
        } else {
          ui.autoInsightsStatus.classList.remove("auto-insights-active");
          ui.autoInsightsStatus.textContent = "ğŸ¤– Auto-Insights Inactive";
        }
      }

      function showLoading(show = true) {
        const existing = document.getElementById("loading-indicator");
        if (existing) existing.remove();

        if (show) {
          const loadingMessages = [
            "ğŸ¤– AI processing your request...",
            "ğŸ§  Analyzing with auto-insights...",
            "âš¡ Working on that for you...",
            "ğŸš€ AI agent is on it...",
            "ğŸ’­ Preparing intelligent response...",
          ];

          const loadingMessage =
            loadingMessages[Math.floor(Math.random() * loadingMessages.length)];

          const loadingWrapper = document.createElement("div");
          loadingWrapper.id = "loading-indicator";
          loadingWrapper.className = "flex mb-4 justify-start";
          loadingWrapper.innerHTML = `
            <div class="max-w-lg px-4 py-3 rounded-2xl bg-slate-200 text-slate-800 flex items-center space-x-2">
              <div class="typing-indicator flex space-x-1">
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce"></div>
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
              </div>
              <span class="text-sm">${loadingMessage}</span>
            </div>
          `;
          ui.chatContainer.appendChild(loadingWrapper);
          ui.chatContainer.scrollTop = ui.chatContainer.scrollHeight;
        }
      }

      async function addMessage(content, sender, type = "text") {
        const messageWrapper = document.createElement("div");
        messageWrapper.className = `flex mb-4 ${
          sender === "user" ? "justify-end" : "justify-start"
        }`;

        const messageContent = document.createElement("div");
        messageWrapper.appendChild(messageContent);
        ui.chatContainer.appendChild(messageWrapper);

        if (type === "card" && sender === "bot") {
          messageContent.className = "max-w-lg lg:max-w-xl";
          try {
            await waitForAdaptiveCards();
            const adaptiveCard = new AdaptiveCards.AdaptiveCard();
            adaptiveCard.hostConfig = new AdaptiveCards.HostConfig({
              fontFamily: "Inter, sans-serif",
            });
            adaptiveCard.parse(content);
            const renderedCard = adaptiveCard.render();
            renderedCard.classList.add("adaptive-card");
            messageContent.appendChild(renderedCard);
          } catch (error) {
            console.error("Adaptive Card rendering failed:", error);
            messageContent.className =
              "max-w-lg lg:max-w-xl px-4 py-3 rounded-2xl bg-slate-200 text-slate-800 whitespace-pre-wrap";
            messageContent.textContent = `Meeting: ${
              content.body?.[1]?.text || "Created Successfully"
            }`;
          }
        } else {
          messageContent.className = `max-w-lg lg:max-w-xl px-4 py-3 rounded-2xl ${
            sender === "user"
              ? "bg-gradient-to-r from-blue-500 to-purple-600 text-white"
              : "bg-slate-200 text-slate-800"
          }`;

          if (typeof content === "object") {
            messageContent.textContent = "Meeting information displayed above.";
          } else {
            const formattedContent = content
              .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
              .replace(/\n/g, "<br>");
            messageContent.innerHTML = formattedContent;
          }
        }

        ui.chatContainer.scrollTop = ui.chatContainer.scrollHeight;
      }

      function waitForAdaptiveCards() {
        return new Promise((resolve, reject) => {
          let retries = 0;
          const maxRetries = 40;
          const interval = setInterval(() => {
            if (window.AdaptiveCards && window.AdaptiveCards.AdaptiveCard) {
              clearInterval(interval);
              resolve();
            } else {
              retries++;
              if (retries > maxRetries) {
                clearInterval(interval);
                reject(new Error("Adaptive Cards library failed to load."));
              }
            }
          }, 250);
        });
      }

      // ====================================================================
      // --- EVENT HANDLERS AND INITIALIZATION ---
      // ====================================================================

      function sendQuickMessage(message) {
        ui.messageInput.value = message;
        handleUserMessage(message);
        ui.messageInput.value = "";
      }

      async function checkApiStatus() {
        // Remove all the fetch logic and just enable the interface
        ui.messageInput.disabled = false;
        ui.sendButton.disabled = false;

        const welcomeMessages = [
          `ğŸš€ **Welcome to Agent 365** - Your Intelligent Meeting Assistant!

**ğŸ¤– Advanced AI Capabilities:**
âœ¨ Smart meeting scheduling with improved date/time parsing
ğŸ“Š Real-time meeting analytics and monitoring  
ğŸ’¬ Intelligent chat analysis and summaries
ğŸ¯ Automatic action item and decision tracking
ğŸ“§ Live email notifications and updates

**ğŸ“… Meeting Management:**
- Schedule Teams meetings with precise date/time handling
- View, cancel, and manage all your meetings
- Get detailed meeting status and information
- Join AI agent for live monitoring and insights

**ğŸ‘¥ Team Collaboration:**
- Find and search team members across your organization
- Send messages to colleagues by name
- Resolve user names to email addresses automatically

**ğŸ’¡ Enhanced Date/Time Examples:**
- "Schedule a meeting tomorrow at 2pm with John Smith"
- "Create meeting next Monday at 10:30am about project review"
- "Book meeting January 15 at 3pm with the team"
- "Set up meeting Friday at 14:00 for status update"

**ğŸ¯ Pro Tips:**
- I now understand natural date/time formats better
- Use specific times like "2:30pm", "14:30", or "2pm"
- Mention weekdays like "next Monday" or "Friday"
- Include meeting topics for better organization

Ready to revolutionize your meeting experience with improved scheduling! ğŸ‰`,
        ];

        const welcomeMsg =
          welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
        addMessage(welcomeMsg, "bot");
      }

      // Event Listeners
      ui.chatForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const message = ui.messageInput.value.trim();
        if (message) {
          handleUserMessage(message);
          ui.messageInput.value = "";
        }
      });

      // Enhanced keyboard shortcuts
      ui.messageInput.addEventListener("keydown", (e) => {
        if (e.key === "Tab") {
          e.preventDefault();
          // Cycle through common commands with improved examples
          const suggestions = [
            "Schedule a meeting tomorrow at 2pm with ",
            "Create meeting next Monday at 10am about ",
            "Show my recent meetings",
            "Find team members named ",
            "Join AI agent to my latest meeting",
            "Get summary of my last meeting",
          ];
          const currentValue = ui.messageInput.value;
          const nextSuggestion =
            suggestions.find((s) => s.startsWith(currentValue)) ||
            suggestions[0];
          ui.messageInput.value = nextSuggestion;
        }
      });

      // Auto-save draft messages
      ui.messageInput.addEventListener("input", (e) => {
        localStorage.setItem("agent365_draft", e.target.value);
      });

      // Restore draft on load
      document.addEventListener("DOMContentLoaded", () => {
        const draft = localStorage.getItem("agent365_draft");
        if (draft) {
          ui.messageInput.value = draft;
        }
        checkApiStatus();
      });

      // Clear draft on send
      ui.chatForm.addEventListener("submit", () => {
        localStorage.removeItem("agent365_draft");
      });

      // Add some helpful tooltips and interactions
      document.addEventListener("DOMContentLoaded", () => {
        // Add tooltip functionality
        const addTooltip = (element, text) => {
          element.addEventListener("mouseenter", () => {
            const tooltip = document.createElement("div");
            tooltip.className =
              "absolute bg-gray-800 text-white text-xs rounded py-1 px-2 z-50";
            tooltip.textContent = text;
            tooltip.style.bottom = "100%";
            tooltip.style.left = "50%";
            tooltip.style.transform = "translateX(-50%)";
            element.style.position = "relative";
            element.appendChild(tooltip);
          });

          element.addEventListener("mouseleave", () => {
            const tooltip = element.querySelector(".absolute");
            if (tooltip) tooltip.remove();
          });
        };

        // Add tooltips to quick action buttons
        const quickButtons = document.querySelectorAll("#quick-actions button");
        const tooltips = [
          "Create a new Teams meeting with improved date/time parsing",
          "View your recent meetings and their status",
          "Search for colleagues in your organization",
          "Send a message to a team member",
          "Add AI agent to monitor your meeting",
          "Generate AI-powered meeting summary",
        ];

        quickButtons.forEach((button, index) => {
          if (tooltips[index]) {
            addTooltip(button, tooltips[index]);
          }
        });
      });

      // Initialize connection check
      document.addEventListener("DOMContentLoaded", () => {
        setTimeout(checkApiStatus, 500); // Small delay to ensure DOM is ready
      });

      // Add some Easter eggs and fun interactions
      let easterEggCount = 0;
      ui.messageInput.addEventListener("input", (e) => {
        if (e.target.value.toLowerCase().includes("hello agent")) {
          easterEggCount++;
          if (easterEggCount === 3) {
            addMessage(
              "ğŸ‰ You found an Easter egg! I love when people are polite! ğŸ¤–âœ¨",
              "bot"
            );
            easterEggCount = 0;
          }
        }
      });

      // Add help command detection
      const originalHandleUserMessage = handleUserMessage;
      handleUserMessage = async function (message) {
        const lowerMessage = message.toLowerCase();

        // Quick help responses
        if (
          lowerMessage === "help" ||
          lowerMessage === "?" ||
          lowerMessage === "/help"
        ) {
          const helpMsg = `ğŸ¤– **Agent 365 Quick Help**

**ğŸ“… Meeting Commands (Improved Date/Time Parsing):**
â€¢ "Schedule a meeting [date] at [time] with [people] about [topic]"
â€¢ "Create meeting tomorrow at 2:30pm with John about project review"
â€¢ "Book meeting next Monday at 10am with the team"
â€¢ "Set up meeting January 15 at 14:30 for status update"
â€¢ "Show my meetings" or "List my recent meetings"
â€¢ "Cancel my meeting about [subject]"

**ğŸ¤– AI Agent Commands:**
â€¢ "Join agent to my [meeting]" - Start live monitoring
â€¢ "Leave agent from my [meeting]" - Stop monitoring
â€¢ "Get summary of my [meeting]" - AI-generated summary
â€¢ "Analyze my [meeting]" - Chat analysis and insights

**ğŸ‘¥ People Commands:**
â€¢ "Find people named [name]"
â€¢ "Show team members"
â€¢ "Send message to [name]: [message]"
â€¢ "Resolve users [name1, name2]"

**ğŸ• Date/Time Formats I Understand:**
â€¢ Relative: "today", "tomorrow", "next Monday", "next week"
â€¢ Specific: "January 15", "2025-01-15", "Friday"
â€¢ Times: "2pm", "14:30", "2:30pm", "10am", "3:00 PM"

**ğŸ’¡ Pro Tips:**
â€¢ Use "latest" or "recent" to refer to your most recent meeting
â€¢ I can understand natural language - just tell me what you need!
â€¢ All meetings are created with auto-insights by default
â€¢ I can resolve names to emails automatically
â€¢ Date/time parsing is now much more accurate!

**ğŸ†˜ Need more help?** Just ask me anything in natural language!`;

          addMessage(helpMsg, "bot");
          return;
        }

        // Status command
        if (lowerMessage === "status" || lowerMessage === "/status") {
          try {
            const response = await fetch(`${API_BASE_URL}/meetings/status`);
            const data = await response.json();

            const statusMsg = `ğŸ“Š **Agent 365 System Status**

**ğŸ”§ Core Services:**
â€¢ Teams Integration: ${
              data.services.teams.available ? "ğŸŸ¢ ACTIVE" : "ğŸ”´ OFFLINE"
            }
â€¢ AI Engine: ${data.services.ai.available ? "ğŸŸ¢ ACTIVE" : "ğŸ”´ OFFLINE"}
â€¢ Auto-Insights: ${
              data.pocFeatures.realAiAgentJoin ? "ğŸŸ¢ READY" : "ğŸ”´ DISABLED"
            }
â€¢ Enhanced Date/Time Parser: ğŸŸ¢ ACTIVE

**ğŸ“ˆ Available Features:**
â€¢ Real Meeting Scheduling: ${
              data.pocFeatures.realMeetingScheduling ? "âœ…" : "âŒ"
            }
â€¢ User Resolution: ${data.pocFeatures.realUserResolution ? "âœ…" : "âŒ"}
â€¢ AI Agent Join: ${data.pocFeatures.realAiAgentJoin ? "âœ…" : "âŒ"}
â€¢ Chat Capture: ${data.pocFeatures.realChatCapture ? "âœ…" : "âŒ"}
â€¢ Summary Generation: ${data.pocFeatures.realSummaryGeneration ? "âœ…" : "âŒ"}
â€¢ Improved Date/Time Parsing: âœ…

**ğŸ’¾ Session Info:**
â€¢ Session ID: ${sessionId}
â€¢ Messages: ${conversationHistory.length}
â€¢ Auto-Insights: ${autoInsightsActive ? "ğŸŸ¢ Active" : "ğŸ”´ Inactive"}

**ğŸŒ API Endpoint:** ${API_BASE_URL}`;

            addMessage(statusMsg, "bot");
            return;
          } catch (error) {
            addMessage(
              "âŒ Could not retrieve system status. Please check connectivity.",
              "bot"
            );
            return;
          }
        }

        // Default to original handler
        return originalHandleUserMessage(message);
      };

      // Add version info
      console.log(`
ğŸ¤– Agent 365 - AI Meeting Assistant
ğŸ“… Version: 2.1.0 with Enhanced Date/Time Parsing
ğŸ”§ Teams Integration: Active
ğŸ’¡ AI Engine: Gemini 2.0 Flash
ğŸ• Date/Time Parser: Enhanced v2.1
ğŸŒ API: ${API_BASE_URL}
      `);
    </script>
  </body>
</html>