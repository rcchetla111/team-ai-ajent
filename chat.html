<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent 365 - AI Meeting Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script
      src="https://unpkg.com/adaptivecards/dist/adaptivecards.min.js"
      crossorigin="anonymous"
    ></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      .adaptive-card {
        border-radius: 0.5rem;
        border: 1px solid #e5e7eb;
      }
      .chat-container::-webkit-scrollbar {
        width: 8px;
      }
      .chat-container::-webkit-scrollbar-track {
        background: #f1f5f9;
      }
      .chat-container::-webkit-scrollbar-thumb {
        background: #94a3b8;
        border-radius: 4px;
      }
      .typing-indicator {
        animation: pulse 1.5s ease-in-out infinite;
      }
      .auto-insights-status {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        margin-left: 10px;
        display: none;
      }
      .auto-insights-active {
        display: inline-block;
        animation: pulse 2s infinite;
      }
      .meeting-card {
        background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        border: 2px solid #0ea5e9;
        border-radius: 12px;
        padding: 16px;
        margin: 8px 0;
      }
      .action-button {
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        color: white;
        padding: 8px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        margin: 4px;
        transition: all 0.3s ease;
      }
      .action-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }
      .status-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
      }
      .status-scheduled {
        background: #dbeafe;
        color: #1e40af;
      }
      .status-in-progress {
        background: #dcfce7;
        color: #166534;
      }
      .status-completed {
        background: #f3e8ff;
        color: #7c3aed;
      }
      .status-cancelled {
        background: #fee2e2;
        color: #dc2626;
      }
    </style>
  </head>
  <body
    class="bg-slate-100 flex flex-col items-center justify-center h-screen p-4"
  >
    <div
      class="w-full max-w-6xl mx-auto flex flex-col h-full bg-white rounded-2xl shadow-2xl"
    >
      <!-- Enhanced Header with Auto-Insights Status -->
      <div
        class="p-4 border-b border-slate-200 flex justify-between items-center"
      >
        <div class="flex items-center space-x-3">
          <div
            class="p-2 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6 text-white"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2 2v10a2 2 0 002 2z"
              />
            </svg>
          </div>
          <div>
            <h1 class="text-lg font-bold text-slate-800">Agent 365</h1>
            <p class="text-sm text-slate-500">
              AI Meeting Assistant with Teams Integration
            </p>
          </div>
          <!-- Auto-Insights Status Indicator -->
          <div class="auto-insights-status" id="auto-insights-status">
            ü§ñ Auto-Insights Active
          </div>
        </div>
      </div>

      <!-- Chat Messages -->
      <div
        id="chat-container"
        class="flex-1 p-6 overflow-y-auto chat-container"
      ></div>

      <!-- Enhanced Message Input -->
      <div class="p-4 border-t border-slate-200 bg-slate-50">
        <div class="flex flex-wrap gap-2 mb-3" id="quick-actions">
          <button
            onclick="sendQuickMessage('Create a meeting tomorrow at 2pm with John Smith about project review')"
            class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-xs hover:bg-blue-200"
          >
            üóìÔ∏è Schedule Meeting
          </button>
          <button
            onclick="sendQuickMessage('Show my recent meetings')"
            class="px-3 py-1 bg-green-100 text-green-700 rounded-full text-xs hover:bg-green-200"
          >
            üìã My Meetings
          </button>
          <button
            onclick="sendQuickMessage('Find team members named John')"
            class="px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs hover:bg-purple-200"
          >
            üë• Find People
          </button>
          <button
            onclick="sendQuickMessage('Send message to Sarah about project update')"
            class="px-3 py-1 bg-orange-100 text-orange-700 rounded-full text-xs hover:bg-orange-200"
          >
            üí¨ Send Message
          </button>
          <button
            onclick="sendQuickMessage('Join AI agent to my latest meeting')"
            class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded-full text-xs hover:bg-indigo-200"
          >
            ü§ñ Join Agent
          </button>
          <button
            onclick="sendQuickMessage('Get summary of my last meeting')"
            class="px-3 py-1 bg-pink-100 text-pink-700 rounded-full text-xs hover:bg-pink-200"
          >
            üìä Meeting Summary
          </button>
        </div>
        <form id="chat-form" class="flex items-center space-x-3">
          <input
            type="text"
            id="message-input"
            class="flex-1 block w-full px-4 py-3 bg-white border border-slate-300 rounded-xl text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:bg-slate-100"
            placeholder="Schedule a meeting, find people, or ask about your calendar..."
            autocomplete="off"
            disabled
          />
          <button
            type="submit"
            id="send-button"
            class="p-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-xl hover:from-blue-600 hover:to-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-slate-300"
            disabled
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"
              />
            </svg>
          </button>
        </form>
      </div>
    </div>

    <script>
      const ui = {
        chatContainer: document.getElementById("chat-container"),
        chatForm: document.getElementById("chat-form"),
        messageInput: document.getElementById("message-input"),
        sendButton: document.getElementById("send-button"),
        autoInsightsStatus: document.getElementById("auto-insights-status"),
      };

      const API_BASE_URL = "http://localhost:5000/api";
      const GEMINI_API_KEY = "AIzaSyBnsIjTRbrHAwKC5ko5K0dvxjp3Cwj5GoQ";
      const GEMINI_MODEL = "gemini-2.0-flash";

      // Enhanced session management
      let sessionId = Date.now();
      let conversationHistory = [];
      let lastCreatedMeeting = null;
      let autoInsightsActive = false;
      let responseVarietyTracker = new Set();
      let userMeetings = [];

      // ====================================================================
      // --- COMPREHENSIVE AGENT TOOLS ---
      // ====================================================================

      const agentTools = [
        {
          name: "create_meeting",
          description:
            "Creates a new Teams meeting with auto-insights and attendee resolution",
          parameters: {
            type: "object",
            properties: {
              subject: { type: "string", description: "Meeting title/subject" },
              description: {
                type: "string",
                description: "Meeting description",
              },
              date: {
                type: "string",
                description: "Date like 'today', 'tomorrow', 'January 15', '2025-01-15'",
              },
              time: {
                type: "string",
                description: "Time like '2pm', '14:30', '3:00 PM'",
              },
              attendees: {
                type: "array",
                items: { type: "string" },
                description: "Names or emails of attendees",
              },
              duration: {
                type: "number",
                description: "Meeting duration in minutes, default 30",
              },
              enableAutoInsights: {
                type: "boolean",
                description: "Enable auto-insights, default true",
              },
              enableChatCapture: {
                type: "boolean",
                description: "Enable chat monitoring, default true",
              },
            },
            required: ["subject", "date", "time"],
          },
        },
        {
          name: "get_meetings",
          description: "Lists user's meetings with filters and details",
          parameters: {
            type: "object",
            properties: {
              status: {
                type: "string",
                enum: ["scheduled", "in_progress", "completed", "cancelled"],
              },
              limit: {
                type: "number",
                description: "Number of meetings to show, default 10",
              },
              detailed: {
                type: "boolean",
                description: "Show detailed meeting info, default false",
              },
            },
          },
        },
        {
          name: "join_meeting_agent",
          description:
            "Join AI agent to a specific meeting for live monitoring",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "leave_meeting_agent",
          description: "Remove AI agent from meeting and generate summary",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "cancel_meeting",
          description: "Cancel a scheduled meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest' for most recent",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_details",
          description: "Get detailed information about a specific meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_summary",
          description: "Generate or retrieve meeting summary with AI insights",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
              regenerate: {
                type: "boolean",
                description: "Force regenerate summary, default false",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "get_meeting_analysis",
          description: "Get detailed chat analysis and insights for a meeting",
          parameters: {
            type: "object",
            properties: {
              meetingIdentifier: {
                type: "string",
                description: "Meeting subject, ID, or 'latest'",
              },
            },
            required: ["meetingIdentifier"],
          },
        },
        {
          name: "find_people",
          description: "Search for team members by name or role",
          parameters: {
            type: "object",
            properties: {
              searchTerm: {
                type: "string",
                description: "Name or role to search for",
              },
              limit: {
                type: "number",
                description: "Max results to return, default 10",
              },
            },
            required: ["searchTerm"],
          },
        },
        {
          name: "get_team_members",
          description: "List all team members in the organization",
          parameters: {
            type: "object",
            properties: {
              limit: {
                type: "number",
                description: "Max members to show, default 20",
              },
              includeDetails: {
                type: "boolean",
                description: "Include job titles and departments",
              },
            },
          },
        },
        {
          name: "send_message",
          description: "Send a message to a team member",
          parameters: {
            type: "object",
            properties: {
              recipient: {
                type: "string",
                description: "Name or email of recipient",
              },
              message: {
                type: "string",
                description: "Message content to send",
              },
            },
            required: ["recipient", "message"],
          },
        },
        {
          name: "resolve_users",
          description: "Resolve user names to emails using Teams directory",
          parameters: {
            type: "object",
            properties: {
              names: {
                type: "array",
                items: { type: "string" },
                description: "Array of names to resolve",
              },
            },
            required: ["names"],
          },
        },
        {
          name: "suggest_meeting_times",
          description:
            "Find optimal meeting times based on attendee availability",
          parameters: {
            type: "object",
            properties: {
              attendees: {
                type: "array",
                items: { type: "string" },
                description: "Attendee emails",
              },
              duration: {
                type: "number",
                description: "Meeting duration in minutes, default 30",
              },
            },
            required: ["attendees"],
          },
        },
        {
          name: "answer_general_question",
          description:
            "Handle general questions, greetings, and provide information",
          parameters: {
            type: "object",
            properties: {
              responseText: { type: "string", description: "Response to user" },
              responseType: {
                type: "string",
                description: "Type of response for variety tracking",
              },
              includeCapabilities: {
                type: "boolean",
                description: "Include capability overview",
              },
            },
            required: ["responseText"],
          },
        },
      ];

      // ====================================================================
      // --- ENHANCED AGENT PROMPT ---
      // ====================================================================

      function getAgentPrompt(history, message) {
        const historyString = history
          .slice(-6)
          .map((turn, index) => `${turn.role}: ${turn.message}`)
          .join("\n");
        const currentDate = new Date().toLocaleDateString();
        const currentTime = new Date().toLocaleTimeString();

        return `You are Agent 365, an advanced AI meeting assistant with full Microsoft Teams integration. You help users manage meetings, find team members, and provide intelligent insights.

**Current Context:**
- Date: ${currentDate}
- Time: ${currentTime}
- Session: ${sessionId}
- Teams Integration: ACTIVE
- Auto-Insights: ENABLED

**Recent Conversation:**
${historyString}

**User Request:** "${message}"

**CRITICAL INSTRUCTIONS FOR MEETING CREATION:**
1. **Always extract the EXACT date and time from user input**
2. **DO NOT modify or calculate relative dates - pass them as provided**
3. **Examples:**
   - User says "tomorrow at 2pm" ‚Üí date: "tomorrow", time: "2pm"
   - User says "January 15 at 3:30pm" ‚Üí date: "January 15", time: "3:30pm"
   - User says "next Monday at 10am" ‚Üí date: "next Monday", time: "10am"
4. **Extract meeting topic/subject from the user's message**
5. **If attendees are mentioned, extract them as an array**

**Your Capabilities:**
1. **Meeting Management:**
   - create_meeting: Schedule Teams meetings with auto-insights
   - get_meetings: List user's meetings with filters
   - cancel_meeting: Cancel scheduled meetings
   - get_meeting_details: Get detailed meeting information

2. **AI Agent Features:**
   - join_meeting_agent: Join agent to meetings for live monitoring
   - leave_meeting_agent: Leave meetings and generate summaries
   - get_meeting_summary: Generate AI-powered meeting summaries
   - get_meeting_analysis: Analyze meeting chat and insights

3. **Team Collaboration:**
   - find_people: Search for team members
   - get_team_members: List all organization members
   - send_message: Send messages to colleagues
   - resolve_users: Convert names to emails

4. **Smart Features:**
   - suggest_meeting_times: Find optimal meeting slots
   - answer_general_question: Handle general queries

**Instructions:**
- Always enable auto-insights for new meetings unless specifically disabled
- Extract dates/times EXACTLY as provided (don't calculate relative dates)
- Use user names naturally - the system will resolve them to emails
- Be proactive about suggesting AI agent features
- Provide varied responses to avoid repetition
- Handle "latest" or "recent" meeting requests intelligently

**Response Format:** Respond with valid JSON: { "tool_name": "...", "parameters": { ... } }

Choose the most appropriate tool for the user's request:`;
      }

      // ====================================================================
      // --- AI RESPONSE GENERATION ---
      // ====================================================================

      async function getAgentAction(message) {
        const prompt = getAgentPrompt(conversationHistory, message);
        console.log("ü§ñ Agent Prompt:", prompt);

        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        try {
          const response = await fetch(API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{ parts: [{ text: prompt }] }],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 1000,
                topP: 0.9,
                topK: 40,
              },
            }),
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Gemini API error: ${errorData.error.message}`);
          }

          const data = await response.json();
          const rawText = data.candidates[0].content.parts[0].text;
          console.log("ü§ñ Raw AI Response:", rawText);

          // IMPROVED JSON PARSING - Fix the malformed JSON issue
          let jsonString = rawText.replace(/```json|```/g, "").trim();

          // Try to find JSON within the response if it's wrapped in other text
          const jsonMatch = jsonString.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            jsonString = jsonMatch[0];
          }

          let action;
          try {
            action = JSON.parse(jsonString);
          } catch (parseError) {
            console.error("JSON Parse Error:", parseError);
            console.error("Failed JSON String:", jsonString);

            // Fallback: create a general response action
            return {
              tool_name: "answer_general_question",
              parameters: {
                responseText:
                  "I understand you'd like help with that. Let me assist you with your meeting and collaboration needs.",
                responseType: "fallback",
              },
            };
          }

          console.log("ü§ñ Parsed Action:", action);
          return action;
        } catch (error) {
          console.error("AI Action Error:", error);
          return {
            tool_name: "answer_general_question",
            parameters: {
              responseText: `I'm having trouble processing that request. Please try rephrasing your request or use one of the quick action buttons.`,
              responseType: "error",
            },
          };
        }
      }

      // ====================================================================
      // --- MESSAGE HANDLING ---
      // ====================================================================

      async function handleUserMessage(message) {
        addMessage(message, "user");
        conversationHistory.push({
          role: "user",
          message: message,
          timestamp: Date.now(),
        });

        showLoading(true);

        const action = await getAgentAction(message);
        if (!action || !action.tool_name) {
          addMessage("I'm not sure how to help with that.", "bot");
          showLoading(false);
          return;
        }

        let agentResponseText = "";
        try {
          switch (action.tool_name) {
            case "create_meeting":
              agentResponseText = await handleCreateMeeting(action.parameters);
              break;
            case "get_meetings":
              agentResponseText = await handleGetMeetings(action.parameters);
              break;
            case "join_meeting_agent":
              agentResponseText = await handleJoinMeetingAgent(
                action.parameters
              );
              break;
            case "leave_meeting_agent":
              agentResponseText = await handleLeaveMeetingAgent(
                action.parameters
              );
              break;
            case "cancel_meeting":
              agentResponseText = await handleCancelMeeting(action.parameters);
              break;
            case "get_meeting_details":
              agentResponseText = await handleGetMeetingDetails(
                action.parameters
              );
              break;
            case "get_meeting_summary":
              agentResponseText = await handleGetMeetingSummary(
                action.parameters
              );
              break;
            case "get_meeting_analysis":
              agentResponseText = await handleGetMeetingAnalysis(
                action.parameters
              );
              break;
            case "find_people":
              agentResponseText = await handleFindPeople(action.parameters);
              break;
            case "get_team_members":
              agentResponseText = await handleGetTeamMembers(action.parameters);
              break;
            case "send_message":
              agentResponseText = await handleSendMessage(action.parameters);
              break;
            case "resolve_users":
              agentResponseText = await handleResolveUsers(action.parameters);
              break;
            case "suggest_meeting_times":
              agentResponseText = await handleSuggestMeetingTimes(
                action.parameters
              );
              break;
            case "answer_general_question":
              agentResponseText =
                action.parameters.responseText ||
                "Hello! How can I help you today?";
              if (action.parameters.includeCapabilities) {
                agentResponseText += "\n\n" + getCapabilitiesOverview();
              }
              addMessage(agentResponseText, "bot");
              // Don't return here, let it continue to update conversation history
              break;
            default:
              agentResponseText = `Unknown command: ${action.tool_name}`;
              addMessage(agentResponseText, "bot");
          }
        } catch (error) {
          console.error("Tool execution error:", error);
          agentResponseText = `Sorry, I encountered an error: ${error.message}`;
          addMessage(agentResponseText, "bot");
        }

        conversationHistory.push({
          role: "agent",
          message: agentResponseText,
          timestamp: Date.now(),
          tool_used: action.tool_name,
        });

        if (conversationHistory.length > 10) {
          conversationHistory = conversationHistory.slice(-10);
        }
        showLoading(false);
      }

      // ====================================================================
      // --- TOOL IMPLEMENTATIONS ---
      // ====================================================================

      async function handleCreateMeeting(params) {
        try {
          console.log("üìÖ Creating meeting with params:", params);
          
          // Enhanced date/time parsing
          const startTime = parseDateTime(params.date, params.time);
          console.log("üïê Parsed start time:", startTime);
          
          const endTime = new Date(
            new Date(startTime).getTime() + (params.duration || 30) * 60000
          ).toISOString();

          // Use /create route instead of /create-with-names
          const payload = {
            subject: params.subject,
            description:
              params.description ||
              `${params.subject} - Created with AI assistance`,
            startTime,
            endTime,
            attendees:  ["support@legacynote.ai"], // Direct emails/names for /create route
            autoJoinAgent: params.enableAutoInsights !== false,
            enableChatCapture: params.enableChatCapture !== false,
          };

          console.log("üì§ Sending payload:", payload);

          // CHANGE THIS LINE - use /create instead of /create-with-names
          const response = await fetch(`${API_BASE_URL}/meetings/create`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          const data = await response.json();
          if (!response.ok) {
            throw new Error(
              data.details || data.error || "Failed to create meeting"
            );
          }

          lastCreatedMeeting = data.meeting;
          userMeetings.unshift(data.meeting);

          if (params.enableAutoInsights !== false) {
            showAutoInsightsStatus(true);
          }

          const meetingCard = createMeetingCard(
            data.meeting,
            data.userResolution
          );
          addMessage(meetingCard, "bot", "card");

          return `‚úÖ Meeting "${
            params.subject
          }" created successfully!\nüïê Scheduled for: ${new Date(startTime).toLocaleString()}\nü§ñ Auto-insights: ${
            params.enableAutoInsights !== false ? "ENABLED" : "DISABLED"
          }\nüë• Attendees: ${data.meeting.attendees?.length || 0}`;
        } catch (error) {
          const msg = `‚ùå Failed to create meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetings(params) {
        try {
          let url = `${API_BASE_URL}/meetings?limit=${params.limit || 10}`;
          if (params.status) {
            url += `&status=${params.status}`;
          }

          const response = await fetch(url);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meetings");
          }

          userMeetings = data.meetings; // Cache for other operations

          if (data.meetings.length === 0) {
            const msg = "üìÖ No meetings found. Would you like to schedule one?";
            addMessage(msg, "bot");
            return msg;
          }

          if (params.detailed) {
            // Show detailed meeting cards
            data.meetings.forEach((meeting) => {
              const card = createMeetingCard(meeting);
              addMessage(card, "bot", "card");
            });
            return `üìã Showing ${data.meetings.length} detailed meeting(s)`;
          } else {
            // Show compact list
            let resultMsg = `üìã **Your Meetings** (${data.meetings.length} found):\n\n`;
            data.meetings.forEach((meeting, index) => {
              const date = new Date(meeting.startTime).toLocaleString();
              const status = getStatusBadge(meeting.status);
              const insights = meeting.agentAttended ? "ü§ñ" : "üë§";

              resultMsg += `${index + 1}. **${meeting.subject}**\n`;
              resultMsg += `   ‚è∞ ${date}\n`;
              resultMsg += `   ${status} ${insights} ${
                meeting.attendees?.length || 0
              } attendees\n\n`;
            });

            addMessage(resultMsg, "bot");
            return resultMsg;
          }
        } catch (error) {
          const msg = `‚ùå Failed to get meetings: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleJoinMeetingAgent(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/join-agent`,
            {
              method: "POST",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to join meeting");
          }

          showAutoInsightsStatus(true);

          const msg =
            `ü§ñ **AI Agent Joined Successfully!**\n\n` +
            `üìã Meeting: "${meeting.subject}"\n` +
            `‚úÖ Auto-insights activated\n` +
            `üí¨ Chat monitoring started\n` +
            `üìä Real-time analytics enabled\n` +
            `üìß Live updates will be sent to attendees\n\n` +
            `The AI agent is now visible to all participants and ready to provide insights!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to join meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleLeaveMeetingAgent(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/leave-agent`,
            {
              method: "POST",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to leave meeting");
          }

          showAutoInsightsStatus(false);

          const msg =
            `üèÅ **AI Agent Left Meeting**\n\n` +
            `üìã Meeting: "${meeting.subject}"\n` +
            `‚úÖ Session completed\n` +
            `üìä Final summary generated\n` +
            `üìß Comprehensive report sent to all attendees\n` +
            `üíæ All insights and analytics saved\n\n` +
            `Check your email for the detailed meeting summary!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to leave meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleCancelMeeting(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}`,
            {
              method: "DELETE",
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to cancel meeting");
          }

          // Update local cache
          userMeetings = userMeetings.filter((m) => m.id !== meeting.id);

          const msg =
            `üóëÔ∏è **Meeting Cancelled Successfully**\n\n` +
            `üìã Meeting: "${meeting.subject}"\n` +
            `‚è∞ Was scheduled for: ${new Date(
              meeting.startTime
            ).toLocaleString()}\n` +
            `üë• ${
              meeting.attendees?.length || 0
            } attendees will be notified\n` +
            `‚úÖ Calendar has been updated\n\n` +
            `All participants will receive cancellation notifications.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to cancel meeting: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingDetails(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/status`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting details");
          }

          const detailCard = createDetailedMeetingCard(
            data.meeting,
            data.timing,
            data.agentStatus
          );
          addMessage(detailCard, "bot", "card");

          return `üìã Detailed information for "${meeting.subject}" displayed above.`;
        } catch (error) {
          const msg = `‚ùå Failed to get meeting details: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingSummary(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          let url = `${API_BASE_URL}/meetings/${meeting.id}/summary`;
          if (params.regenerate) {
            url += `?regenerate=true`;
          }

          const response = await fetch(url);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting summary");
          }

          const summary = data.summary;
          let msg = `üìã **AI-Generated Meeting Summary**\n\n`;
          msg += `üè¢ **Meeting:** ${meeting.subject}\n`;
          msg += `üìÖ **Date:** ${new Date(
            meeting.startTime
          ).toLocaleString()}\n\n`;

          if (summary.executiveSummary) {
            msg += `üìù **Executive Summary:**\n${summary.executiveSummary}\n\n`;
          }

          if (summary.actionItems && summary.actionItems.length > 0) {
            msg += `‚úÖ **Action Items (${summary.actionItems.length}):**\n`;
            summary.actionItems.forEach((item, index) => {
              msg += `${index + 1}. ${item.task}\n`;
              if (item.assignee) msg += `   üë§ Assigned to: ${item.assignee}\n`;
              if (item.deadline) msg += `   üìÖ Due: ${item.deadline}\n`;
            });
            msg += `\n`;
          }

          if (summary.metrics) {
            msg += `üìä **Meeting Metrics:**\n`;
            msg += `‚Ä¢ Messages: ${summary.metrics.totalMessages || 0}\n`;
            msg += `‚Ä¢ Questions: ${summary.metrics.questionsAsked || 0}\n`;
            msg += `‚Ä¢ Decisions: ${summary.metrics.decisionsTracked || 0}\n\n`;
          }

          if (summary.qualityScores) {
            msg += `üéØ **Quality Score:** ${summary.qualityScores.overall}/10\n\n`;
          }

          msg += `ü§ñ Generated with AI auto-insights`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to get meeting summary: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetMeetingAnalysis(params) {
        try {
          const meeting = await findMeetingByIdentifier(
            params.meetingIdentifier
          );

          const response = await fetch(
            `${API_BASE_URL}/meetings/${meeting.id}/chat-analysis`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting analysis");
          }

          const analysis = data.analysis;
          let msg = `üìä **Meeting Chat Analysis**\n\n`;
          msg += `üè¢ **Meeting:** ${meeting.subject}\n`;
          msg += `üí¨ **Total Messages:** ${analysis.totalMessages}\n\n`;

          if (analysis.categorizedCounts) {
            msg += `üìà **Message Categories:**\n`;
            msg += `‚Ä¢ ‚ùì Questions: ${analysis.categorizedCounts.questions}\n`;
            msg += `‚Ä¢ ‚úÖ Action Items: ${analysis.categorizedCounts.actionItems}\n`;
            msg += `‚Ä¢ üéØ Decisions: ${analysis.categorizedCounts.decisions}\n`;
            msg += `‚Ä¢ üìé Shared Resources: ${analysis.categorizedCounts.sharedResources}\n\n`;
          }

          if (analysis.participantAnalysis) {
            msg += `üë• **Top Participants:**\n`;
            Object.entries(analysis.participantAnalysis)
              .sort(([, a], [, b]) => b.messageCount - a.messageCount)
              .slice(0, 3)
              .forEach(([name, stats]) => {
                msg += `‚Ä¢ **${name}**: ${stats.messageCount} messages\n`;
              });
            msg += `\n`;
          }

          if (analysis.keyInsights) {
            msg += `üí° **Key Insights:**\n`;
            if (analysis.keyInsights.mostActiveParticipant) {
              msg += `üèÜ Most Active: ${analysis.keyInsights.mostActiveParticipant}\n`;
            }
          }

          msg += `\nü§ñ Analysis powered by auto-insights AI`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to get meeting analysis: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleFindPeople(params) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/users/search?q=${encodeURIComponent(
              params.searchTerm
            )}&limit=${params.limit || 10}`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to search people");
          }

          if (data.users.length === 0) {
            const msg = `üîç No team members found matching "${params.searchTerm}". Try a different search term.`;
            addMessage(msg, "bot");
            return msg;
          }

          let msg = `üë• **Found ${data.users.length} team member(s) for "${params.searchTerm}":**\n\n`;
          data.users.forEach((user, index) => {
            msg += `${index + 1}. **${user.name}**\n`;
            msg += `   üìß ${user.email}\n`;
            if (user.jobTitle) msg += `   üíº ${user.jobTitle}\n`;
            if (user.department) msg += `   üè¢ ${user.department}\n`;
            msg += `\n`;
          });

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to find people: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleGetTeamMembers(params) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/users?limit=${params.limit || 20}`
          );
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get team members");
          }

          if (data.users.length === 0) {
            const msg = "üë• No team members found in the directory.";
            addMessage(msg, "bot");
            return msg;
          }

          let msg = `üë• **Team Directory** (${data.total} total members):\n\n`;
          data.users.slice(0, 15).forEach((user, index) => {
            msg += `${index + 1}. **${user.name}**\n`;
            msg += `   üìß ${user.email}\n`;
            if (params.includeDetails) {
              if (user.jobTitle) msg += `   üíº ${user.jobTitle}\n`;
              if (user.department) msg += `   üè¢ ${user.department}\n`;
            }
            msg += `\n`;
          });

          if (data.total > 15) {
            msg += `... and ${data.total - 15} more members\n\n`;
          }

          msg += `üí° Use "find people named [name]" to search for specific team members.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to get team members: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleSendMessage(params) {
        try {
          const response = await fetch(`${API_BASE_URL}/users/resolve`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ names: [params.recipient] }),
          });

          const userData = await response.json();
          if (!response.ok || userData.resolvedUsers.length === 0) {
            throw new Error(`Could not find user: ${params.recipient}`);
          }

          const resolvedUser = userData.resolvedUsers[0];

          // In a real implementation, you would send the message via Teams/email
          // For now, we'll simulate the message sending
          const msg =
            `‚úÖ **Message Sent Successfully!**\n\n` +
            `üë§ **To:** ${resolvedUser.name}\n` +
            `üìß **Email:** ${resolvedUser.email}\n` +
            `üí¨ **Message:** "${params.message}"\n\n` +
            `üì¨ Your message has been delivered and they should receive it shortly.`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to send message: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleResolveUsers(params) {
        try {
          const response = await fetch(`${API_BASE_URL}/users/resolve`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ names: params.names }),
          });

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to resolve users");
          }

          let msg = `üîç **User Resolution Results:**\n\n`;
          msg += `üìä Success Rate: ${data.summary?.successRate || "N/A"}\n`;
          msg += `‚úÖ Found: ${data.resolvedUsers.length}/${params.names.length}\n\n`;

          if (data.resolvedUsers.length > 0) {
            msg += `**Resolved Users:**\n`;
            data.resolvedUsers.forEach((user, index) => {
              msg += `${index + 1}. **${user.name}** ‚Üí ${user.email}\n`;
            });
          }

          if (data.resolvedUsers.length < params.names.length) {
            const notFound = params.names.filter(
              (name) =>
                !data.resolvedUsers.some((user) =>
                  user.name.toLowerCase().includes(name.toLowerCase())
                )
            );
            msg += `\n‚ùå **Not Found:** ${notFound.join(", ")}`;
          }

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to resolve users: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      async function handleSuggestMeetingTimes(params) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/meetings/suggest-times`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                attendees: params.attendees,
                duration: params.duration || 30,
              }),
            }
          );

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to get meeting suggestions");
          }

          let msg = `üïê **Optimal Meeting Times**\n\n`;
          msg += `üë• Checked availability for ${params.attendees.length} attendees\n`;
          msg += `‚è±Ô∏è Duration: ${params.duration || 30} minutes\n\n`;

          if (data.suggestions && data.suggestions.length > 0) {
            msg += `**üìÖ Suggested Times:**\n`;
            data.suggestions.slice(0, 5).forEach((suggestion, index) => {
              const startTime = new Date(suggestion.startTime).toLocaleString();
              const endTime = new Date(suggestion.endTime).toLocaleString();
              msg += `${index + 1}. ${startTime} - ${endTime}\n`;
              if (suggestion.confidence) {
                msg += `   üìä Confidence: ${Math.round(
                  suggestion.confidence * 100
                )}%\n`;
              }
            });
          } else {
            msg += `‚ùå No optimal times found. Try different attendees or duration.`;
          }

          msg += `\n\nüí° Use these times when creating your meeting for best attendance!`;

          addMessage(msg, "bot");
          return msg;
        } catch (error) {
          const msg = `‚ùå Failed to suggest meeting times: ${error.message}`;
          addMessage(msg, "bot");
          return msg;
        }
      }

      // ====================================================================
      // --- UTILITY FUNCTIONS ---
      // ====================================================================

      async function findMeetingByIdentifier(identifier) {
        // First try to get fresh meeting list
        try {
          const response = await fetch(`${API_BASE_URL}/meetings?limit=20`);
          const data = await response.json();
          if (response.ok) {
            userMeetings = data.meetings;
          }
        } catch (error) {
          console.warn("Could not refresh meeting list:", error);
        }

        if (
          identifier.toLowerCase() === "latest" ||
          identifier.toLowerCase() === "recent"
        ) {
          if (userMeetings.length === 0) {
            throw new Error("No meetings found. Create a meeting first.");
          }
          return userMeetings[0]; // Most recent
        }

        // Try to find by ID first
        let meeting = userMeetings.find(
          (m) => m.id === identifier || m.meetingId === identifier
        );

        // If not found, try by subject (partial match)
        if (!meeting) {
          meeting = userMeetings.find((m) =>
            m.subject.toLowerCase().includes(identifier.toLowerCase())
          );
        }

        if (!meeting) {
          throw new Error(
            `Meeting not found: "${identifier}". Try using the exact meeting subject or "latest".`
          );
        }

        return meeting;
      }

      // ====================================================================
      // --- COMPREHENSIVE DATE/TIME PARSING FUNCTION ---
      // ====================================================================

      function parseDateTime(dateStr, timeStr) {
        console.log("üïê Parsing date/time:", { dateStr, timeStr });
        
        const now = new Date();
        let meetingDate = new Date(now);
        
        // ============ ENHANCED DATE PARSING ============
        if (dateStr) {
          const dateLower = dateStr.toLowerCase().trim();
          let dateResolved = false;
          
          // Relative dates
          if (dateLower === "today") {
            meetingDate = new Date(now);
            dateResolved = true;
          } else if (dateLower === "tomorrow") {
            meetingDate = new Date(now);
            meetingDate.setDate(now.getDate() + 1);
            dateResolved = true;
          } else if (dateLower.includes("next week")) {
            meetingDate = new Date(now);
            meetingDate.setDate(now.getDate() + 7);
            dateResolved = true;
          }
          
          // Weekdays
          const weekdays = {
            'monday': 1, 'tuesday': 2, 'wednesday': 3, 'thursday': 4,
            'friday': 5, 'saturday': 6, 'sunday': 0
          };
          
          for (const [day, dayNum] of Object.entries(weekdays)) {
            if (dateLower.includes(day)) {
              meetingDate = getNextWeekday(now, dayNum);
              dateResolved = true;
              break;
            }
          }
          
          // Month names parsing (comprehensive)
          if (!dateResolved) {
            const monthNames = {
              'january': 0, 'jan': 0, 'february': 1, 'feb': 1, 'march': 2, 'mar': 2,
              'april': 3, 'apr': 3, 'may': 4, 'june': 5, 'jun': 5,
              'july': 6, 'jul': 6, 'august': 7, 'aug': 7, 'september': 8, 'sep': 8,
              'october': 9, 'oct': 9, 'november': 10, 'nov': 10, 'december': 11, 'dec': 11
            };
            
            // Patterns: "15 august", "august 15", "15th august", "aug 15"
            const patterns = [
              /(\d{1,2})(?:st|nd|rd|th)?\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
              /(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})(?:st|nd|rd|th)?/i
            ];
            
            for (const pattern of patterns) {
              const match = dateLower.match(pattern);
              if (match) {
                let day, monthName;
                if (/\d/.test(match[1])) {
                  day = parseInt(match[1]);
                  monthName = match[2].toLowerCase();
                } else {
                  day = parseInt(match[2]);
                  monthName = match[1].toLowerCase();
                }
                
                const monthIndex = monthNames[monthName];
                if (monthIndex !== undefined && day >= 1 && day <= 31) {
                  meetingDate = new Date(now.getFullYear(), monthIndex, day);
                  
                  // If date is in the past, move to next year
                  if (meetingDate < new Date(now.getFullYear(), now.getMonth(), now.getDate())) {
                    meetingDate.setFullYear(now.getFullYear() + 1);
                  }
                  dateResolved = true;
                  break;
                }
              }
            }
          }
          
          // Numeric date patterns: "15/8", "8/15", "15-8", "2025-08-15"
          if (!dateResolved) {
            const numericPatterns = [
              /(\d{4})-(\d{1,2})-(\d{1,2})/,     // YYYY-MM-DD
              /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,  // DD/MM/YYYY or MM/DD/YYYY
              /(\d{1,2})[\/\-](\d{1,2})/,       // DD/MM or MM/DD
            ];
            
            for (const pattern of numericPatterns) {
              const match = dateStr.match(pattern);
              if (match) {
                let year, month, day;
                
                if (match[0].includes(match[1]) && match[1].length === 4) {
                  // YYYY-MM-DD format
                  year = parseInt(match[1]);
                  month = parseInt(match[2]) - 1;
                  day = parseInt(match[3]);
                } else if (match[3]) {
                  // With year
                  year = parseInt(match[3]);
                  // Assume DD/MM/YYYY for ambiguous cases
                  day = parseInt(match[1]);
                  month = parseInt(match[2]) - 1;
                } else {
                  // Without year - assume current year
                  year = now.getFullYear();
                  // Decide between DD/MM and MM/DD
                  const num1 = parseInt(match[1]);
                  const num2 = parseInt(match[2]);
                  
                  if (num1 > 12) {
                    day = num1;
                    month = num2 - 1;
                  } else if (num2 > 12) {
                    day = num2;
                    month = num1 - 1;
                  } else {
                    // Both <= 12, assume DD/MM
                    day = num1;
                    month = num2 - 1;
                  }
                }
                
                meetingDate = new Date(year, month, day);
                if (!isNaN(meetingDate.getTime())) {
                  if (meetingDate < new Date(now.getFullYear(), now.getMonth(), now.getDate())) {
                    meetingDate.setFullYear(now.getFullYear() + 1);
                  }
                  dateResolved = true;
                  break;
                }
              }
            }
          }
          
          // Fallback: try native Date parsing
          if (!dateResolved) {
            const fallbackFormats = [
              `${dateStr} ${now.getFullYear()}`,
              `${now.getFullYear()}-${dateStr}`,
              dateStr
            ];
            
            for (const format of fallbackFormats) {
              const testDate = new Date(format);
              if (!isNaN(testDate.getTime()) && testDate.getFullYear() >= now.getFullYear()) {
                meetingDate = testDate;
                dateResolved = true;
                break;
              }
            }
          }
        }

        // ============ ENHANCED TIME PARSING ============
        if (timeStr) {
          const timeLower = timeStr.toLowerCase().trim();
          console.log("üïê Parsing time:", timeLower);
          
          let hours = null;
          let minutes = 0;
          
          // Comprehensive time patterns
          const timePatterns = [
            // 12-hour format with AM/PM
            /(\d{1,2}):(\d{2})\s*(am|pm)/i,           // 2:30pm, 10:15am
            /(\d{1,2})\s*(am|pm)/i,                   // 2pm, 10am
            /(\d{1,2})\.(\d{2})\s*(am|pm)/i,          // 2.30pm
            
            // 24-hour format
            /(\d{1,2}):(\d{2})$/,                     // 14:30, 02:15
            /(\d{1,2})\.(\d{2})$/,                    // 14.30, 02.15
            /(\d{1,2})h(\d{2})/i,                     // 14h30, 2h15
            /(\d{1,2})h$/i,                           // 14h, 2h
            
            // Simple hour formats
            /^(\d{1,2})$/,                            // 14, 2 (assume 24h if >12, otherwise next occurrence)
          ];
          
          for (const pattern of timePatterns) {
            const match = timeLower.match(pattern);
            if (match) {
              hours = parseInt(match[1], 10);
              minutes = match[2] ? parseInt(match[2], 10) : 0;
              
              // Handle AM/PM conversion
              if (match[3]) {
                const period = match[3].toLowerCase();
                if (period === 'pm' && hours < 12) {
                  hours += 12;
                } else if (period === 'am' && hours === 12) {
                  hours = 0;
                }
              } else if (hours <= 12 && !timeLower.includes(':') && !timeLower.includes('.') && !timeLower.includes('h')) {
                // For simple hour format, assume PM if it's a reasonable time
                if (hours >= 8 && hours <= 11) {
                  // Could be AM or PM, check context
                  const currentHour = now.getHours();
                  if (currentHour >= 12) {
                    hours += 12; // Assume PM if it's afternoon
                  }
                }
              }
              
              // Validate time
              if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
                break;
              } else {
                hours = null; // Invalid time, continue to next pattern
              }
            }
          }
          
          // Special cases for common time expressions
          if (hours === null) {
            const specialTimes = {
              'morning': [9, 0],
              'noon': [12, 0],
              'afternoon': [14, 0],
              'evening': [18, 0],
              'night': [20, 0],
              'midnight': [0, 0]
            };
            
            for (const [timeWord, [h, m]] of Object.entries(specialTimes)) {
              if (timeLower.includes(timeWord)) {
                hours = h;
                minutes = m;
                break;
              }
            }
          }
          
          // Apply time to meeting date
          if (hours !== null) {
            meetingDate.setHours(hours, minutes, 0, 0);
            console.log("üïê Set time to:", hours, ":", minutes);
          } else {
            console.warn("‚ö†Ô∏è Could not parse time:", timeStr);
            // Default to next hour
            const nextHour = new Date(now.getTime() + 3600000);
            meetingDate.setHours(nextHour.getHours(), 0, 0, 0);
          }
        } else {
          // No time specified - default to next reasonable hour
          const nextHour = new Date(now.getTime() + 3600000);
          meetingDate.setHours(nextHour.getHours(), 0, 0, 0);
        }

        // ============ FINAL VALIDATION ============
        // Ensure the meeting is in the future
        if (meetingDate.getTime() <= now.getTime()) {
          if (dateStr && timeStr) {
            // Both date and time specified but in past - move to next occurrence
            meetingDate.setDate(meetingDate.getDate() + 1);
          } else {
            // Only time specified or default - move to next valid time
            meetingDate = new Date(now.getTime() + 3600000); // 1 hour from now
          }
        }

        const result = meetingDate.toISOString();
        console.log("üïê Final parsed datetime:", result, "Local:", meetingDate.toLocaleString());
        return result;
      }

      // Helper function to get next occurrence of a weekday
      function getNextWeekday(date, targetDay) {
        const result = new Date(date);
        const currentDay = result.getDay();
        let daysToAdd = targetDay - currentDay;
        
        if (daysToAdd <= 0) {
          daysToAdd += 7; // Next week
        }
        
        result.setDate(result.getDate() + daysToAdd);
        return result;
      }

      function getStatusBadge(status) {
        const badges = {
          scheduled: "üìÖ Scheduled",
          in_progress: "üü¢ In Progress",
          completed: "‚úÖ Completed",
          cancelled: "‚ùå Cancelled",
        };
        return badges[status] || "‚ùî Unknown";
      }

      function getCapabilitiesOverview() {
        return `**ü§ñ My Capabilities:**

**üìÖ Meeting Management:**
‚Ä¢ Schedule Teams meetings with auto-insights
‚Ä¢ View, cancel, and manage your meetings
‚Ä¢ Get detailed meeting information and status

**ü§ñ AI Agent Features:**
‚Ä¢ Join meetings for live monitoring and insights
‚Ä¢ Generate comprehensive meeting summaries
‚Ä¢ Analyze meeting chat and participant engagement

**üë• Team Collaboration:**
‚Ä¢ Find and search team members
‚Ä¢ Send messages to colleagues
‚Ä¢ Resolve names to email addresses

**üí° Smart Features:**
‚Ä¢ Suggest optimal meeting times
‚Ä¢ Auto-insights with real-time notifications
‚Ä¢ Meeting analytics and quality scoring

Try commands like:
‚Ä¢ "Schedule a meeting tomorrow at 2pm with John"
‚Ä¢ "Show my recent meetings"
‚Ä¢ "Join AI agent to my latest meeting"
‚Ä¢ "Find team members named Sarah"`;
      }

      // ====================================================================
      // --- UI COMPONENTS ---
      // ====================================================================

      function createMeetingCard(meeting, userResolution = null) {
        const attendeesText = userResolution
          ? `${userResolution.usersResolved}/${userResolution.namesRequested} resolved`
          : `${meeting.attendees?.length || 0} attendees`;

        const insightsStatus = meeting.agentAttended
          ? "‚úÖ ENABLED"
          : "‚ö†Ô∏è DISABLED";
        const startTime = new Date(meeting.startTime).toLocaleString();

        return {
          type: "AdaptiveCard",
          version: "1.4",
          body: [
            {
              type: "TextBlock",
              text: "üìÖ Meeting Created Successfully!",
              weight: "Bolder",
              size: "Medium",
              color: "Good",
            },
            {
              type: "TextBlock",
              text: meeting.subject,
              weight: "Bolder",
              size: "Large",
              wrap: true,
            },
            {
              type: "TextBlock",
              text: `üïê ${startTime}`,
              spacing: "Small",
              wrap: true,
            },
            {
              type: "FactSet",
              spacing: "Medium",
              facts: [
                { title: "üë• Attendees:", value: attendeesText },
                { title: "ü§ñ Auto-Insights:", value: insightsStatus },
                { title: "üìä Status:", value: getStatusBadge(meeting.status) },
                { title: "üîó Meeting Type:", value: "Microsoft Teams" },
              ],
            },
          ],
          actions: [
            {
              type: "Action.OpenUrl",
              title: "üîó Join Meeting",
              url: meeting.joinUrl || "#",
              style: "positive",
            },
            {
              type: "Action.OpenUrl",
              title: "üìÖ View in Calendar",
              url: meeting.webUrl || "#",
            },
          ],
        };
      }

      function createDetailedMeetingCard(meeting, timing, agentStatus) {
        return {
          type: "AdaptiveCard",
          version: "1.4",
          body: [
            {
              type: "TextBlock",
              text: "üìã Meeting Details",
              weight: "Bolder",
              size: "Medium",
              color: "Accent",
            },
            {
              type: "TextBlock",
              text: meeting.subject,
              weight: "Bolder",
              size: "Large",
              wrap: true,
            },
            {
              type: "FactSet",
              spacing: "Medium",
              facts: [
                {
                  title: "üìÖ Start Time:",
                  value: new Date(meeting.startTime).toLocaleString(),
                },
                {
                  title: "‚è∞ End Time:",
                  value: new Date(meeting.endTime).toLocaleString(),
                },
                { title: "üìä Status:", value: getStatusBadge(meeting.status) },
                {
                  title: "üë• Attendees:",
                  value: `${meeting.attendees?.length || 0}`,
                },
                {
                  title: "ü§ñ AI Agent:",
                  value: agentStatus.isAttending ? "Active" : "Inactive",
                },
                {
                  title: "‚è±Ô∏è Duration:",
                  value: `${timing.meetingDuration} minutes`,
                },
              ],
            },
            {
              type: "TextBlock",
              text: timing.hasStarted
                ? timing.hasEnded
                  ? "‚úÖ Meeting completed"
                  : "üü¢ Meeting in progress"
                : `‚è≥ Starts in ${Math.abs(timing.minutesUntilStart)} minutes`,
              spacing: "Medium",
              wrap: true,
              color: timing.hasStarted
                ? timing.hasEnded
                  ? "Good"
                  : "Attention"
                : "Default",
            },
          ],
          actions:
            meeting.status === "scheduled"
              ? [
                  {
                    type: "Action.OpenUrl",
                    title: "üîó Join Meeting",
                    url: meeting.joinUrl || "#",
                    style: "positive",
                  },
                ]
              : [],
        };
      }

      function showAutoInsightsStatus(active) {
        autoInsightsActive = active;
        if (active) {
          ui.autoInsightsStatus.classList.add("auto-insights-active");
          ui.autoInsightsStatus.textContent = "ü§ñ Auto-Insights Active";
        } else {
          ui.autoInsightsStatus.classList.remove("auto-insights-active");
          ui.autoInsightsStatus.textContent = "ü§ñ Auto-Insights Inactive";
        }
      }

      function showLoading(show = true) {
        const existing = document.getElementById("loading-indicator");
        if (existing) existing.remove();

        if (show) {
          const loadingMessages = [
            "ü§ñ AI processing your request...",
            "üß† Analyzing with auto-insights...",
            "‚ö° Working on that for you...",
            "üöÄ AI agent is on it...",
            "üí≠ Preparing intelligent response...",
          ];

          const loadingMessage =
            loadingMessages[Math.floor(Math.random() * loadingMessages.length)];

          const loadingWrapper = document.createElement("div");
          loadingWrapper.id = "loading-indicator";
          loadingWrapper.className = "flex mb-4 justify-start";
          loadingWrapper.innerHTML = `
            <div class="max-w-lg px-4 py-3 rounded-2xl bg-slate-200 text-slate-800 flex items-center space-x-2">
              <div class="typing-indicator flex space-x-1">
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce"></div>
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                <div class="w-2 h-2 bg-slate-500 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
              </div>
              <span class="text-sm">${loadingMessage}</span>
            </div>
          `;
          ui.chatContainer.appendChild(loadingWrapper);
          ui.chatContainer.scrollTop = ui.chatContainer.scrollHeight;
        }
      }

      async function addMessage(content, sender, type = "text") {
        const messageWrapper = document.createElement("div");
        messageWrapper.className = `flex mb-4 ${
          sender === "user" ? "justify-end" : "justify-start"
        }`;

        const messageContent = document.createElement("div");
        messageWrapper.appendChild(messageContent);
        ui.chatContainer.appendChild(messageWrapper);

        if (type === "card" && sender === "bot") {
          messageContent.className = "max-w-lg lg:max-w-xl";
          try {
            await waitForAdaptiveCards();
            const adaptiveCard = new AdaptiveCards.AdaptiveCard();
            adaptiveCard.hostConfig = new AdaptiveCards.HostConfig({
              fontFamily: "Inter, sans-serif",
            });
            adaptiveCard.parse(content);
            const renderedCard = adaptiveCard.render();
            renderedCard.classList.add("adaptive-card");
            messageContent.appendChild(renderedCard);
          } catch (error) {
            console.error("Adaptive Card rendering failed:", error);
            messageContent.className =
              "max-w-lg lg:max-w-xl px-4 py-3 rounded-2xl bg-slate-200 text-slate-800 whitespace-pre-wrap";
            messageContent.textContent = `Meeting: ${
              content.body?.[1]?.text || "Created Successfully"
            }`;
          }
        } else {
          messageContent.className = `max-w-lg lg:max-w-xl px-4 py-3 rounded-2xl ${
            sender === "user"
              ? "bg-gradient-to-r from-blue-500 to-purple-600 text-white"
              : "bg-slate-200 text-slate-800"
          }`;

          if (typeof content === "object") {
            messageContent.textContent = "Meeting information displayed above.";
          } else {
            const formattedContent = content
              .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
              .replace(/\n/g, "<br>");
            messageContent.innerHTML = formattedContent;
          }
        }

        ui.chatContainer.scrollTop = ui.chatContainer.scrollHeight;
      }

      function waitForAdaptiveCards() {
        return new Promise((resolve, reject) => {
          let retries = 0;
          const maxRetries = 40;
          const interval = setInterval(() => {
            if (window.AdaptiveCards && window.AdaptiveCards.AdaptiveCard) {
              clearInterval(interval);
              resolve();
            } else {
              retries++;
              if (retries > maxRetries) {
                clearInterval(interval);
                reject(new Error("Adaptive Cards library failed to load."));
              }
            }
          }, 250);
        });
      }

      // ====================================================================
      // --- EVENT HANDLERS AND INITIALIZATION ---
      // ====================================================================

      function sendQuickMessage(message) {
        ui.messageInput.value = message;
        handleUserMessage(message);
        ui.messageInput.value = "";
      }

      async function checkApiStatus() {
        // Remove all the fetch logic and just enable the interface
        ui.messageInput.disabled = false;
        ui.sendButton.disabled = false;

        const welcomeMessages = [
          `üöÄ **Welcome to Agent 365** - Your Intelligent Meeting Assistant!

**ü§ñ Advanced AI Capabilities:**
‚ú® Smart meeting scheduling with improved date/time parsing
üìä Real-time meeting analytics and monitoring  
üí¨ Intelligent chat analysis and summaries
üéØ Automatic action item and decision tracking
üìß Live email notifications and updates

**üìÖ Meeting Management:**
- Schedule Teams meetings with precise date/time handling
- View, cancel, and manage all your meetings
- Get detailed meeting status and information
- Join AI agent for live monitoring and insights

**üë• Team Collaboration:**
- Find and search team members across your organization
- Send messages to colleagues by name
- Resolve user names to email addresses automatically

**üí° Enhanced Date/Time Examples:**
- "Schedule a meeting tomorrow at 2pm with John Smith"
- "Create meeting next Monday at 10:30am about project review"
- "Book meeting January 15 at 3pm with the team"
- "Set up meeting Friday at 14:00 for status update"

**üéØ Pro Tips:**
- I now understand natural date/time formats better
- Use specific times like "2:30pm", "14:30", or "2pm"
- Mention weekdays like "next Monday" or "Friday"
- Include meeting topics for better organization

Ready to revolutionize your meeting experience with improved scheduling! üéâ`,
        ];

        const welcomeMsg =
          welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
        addMessage(welcomeMsg, "bot");
      }

      // Event Listeners
      ui.chatForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const message = ui.messageInput.value.trim();
        if (message) {
          handleUserMessage(message);
          ui.messageInput.value = "";
        }
      });

      // Enhanced keyboard shortcuts
      ui.messageInput.addEventListener("keydown", (e) => {
        if (e.key === "Tab") {
          e.preventDefault();
          // Cycle through common commands with improved examples
          const suggestions = [
            "Schedule a meeting tomorrow at 2pm with ",
            "Create meeting next Monday at 10am about ",
            "Show my recent meetings",
            "Find team members named ",
            "Join AI agent to my latest meeting",
            "Get summary of my last meeting",
          ];
          const currentValue = ui.messageInput.value;
          const nextSuggestion =
            suggestions.find((s) => s.startsWith(currentValue)) ||
            suggestions[0];
          ui.messageInput.value = nextSuggestion;
        }
      });

      // Auto-save draft messages
      ui.messageInput.addEventListener("input", (e) => {
        localStorage.setItem("agent365_draft", e.target.value);
      });

      // Restore draft on load
      document.addEventListener("DOMContentLoaded", () => {
        const draft = localStorage.getItem("agent365_draft");
        if (draft) {
          ui.messageInput.value = draft;
        }
        checkApiStatus();
      });

      // Clear draft on send
      ui.chatForm.addEventListener("submit", () => {
        localStorage.removeItem("agent365_draft");
      });

      // Add some helpful tooltips and interactions
      document.addEventListener("DOMContentLoaded", () => {
        // Add tooltip functionality
        const addTooltip = (element, text) => {
          element.addEventListener("mouseenter", () => {
            const tooltip = document.createElement("div");
            tooltip.className =
              "absolute bg-gray-800 text-white text-xs rounded py-1 px-2 z-50";
            tooltip.textContent = text;
            tooltip.style.bottom = "100%";
            tooltip.style.left = "50%";
            tooltip.style.transform = "translateX(-50%)";
            element.style.position = "relative";
            element.appendChild(tooltip);
          });

          element.addEventListener("mouseleave", () => {
            const tooltip = element.querySelector(".absolute");
            if (tooltip) tooltip.remove();
          });
        };

        // Add tooltips to quick action buttons
        const quickButtons = document.querySelectorAll("#quick-actions button");
        const tooltips = [
          "Create a new Teams meeting with improved date/time parsing",
          "View your recent meetings and their status",
          "Search for colleagues in your organization",
          "Send a message to a team member",
          "Add AI agent to monitor your meeting",
          "Generate AI-powered meeting summary",
        ];

        quickButtons.forEach((button, index) => {
          if (tooltips[index]) {
            addTooltip(button, tooltips[index]);
          }
        });
      });

      // Initialize connection check
      document.addEventListener("DOMContentLoaded", () => {
        setTimeout(checkApiStatus, 500); // Small delay to ensure DOM is ready
      });

      // Add some Easter eggs and fun interactions
      let easterEggCount = 0;
      ui.messageInput.addEventListener("input", (e) => {
        if (e.target.value.toLowerCase().includes("hello agent")) {
          easterEggCount++;
          if (easterEggCount === 3) {
            addMessage(
              "üéâ You found an Easter egg! I love when people are polite! ü§ñ‚ú®",
              "bot"
            );
            easterEggCount = 0;
          }
        }
      });

      // Add help command detection
      const originalHandleUserMessage = handleUserMessage;
      handleUserMessage = async function (message) {
        const lowerMessage = message.toLowerCase();

        // Quick help responses
        if (
          lowerMessage === "help" ||
          lowerMessage === "?" ||
          lowerMessage === "/help"
        ) {
          const helpMsg = `ü§ñ **Agent 365 Quick Help**

**üìÖ Meeting Commands (Improved Date/Time Parsing):**
‚Ä¢ "Schedule a meeting [date] at [time] with [people] about [topic]"
‚Ä¢ "Create meeting tomorrow at 2:30pm with John about project review"
‚Ä¢ "Book meeting next Monday at 10am with the team"
‚Ä¢ "Set up meeting January 15 at 14:30 for status update"
‚Ä¢ "Show my meetings" or "List my recent meetings"
‚Ä¢ "Cancel my meeting about [subject]"

**ü§ñ AI Agent Commands:**
‚Ä¢ "Join agent to my [meeting]" - Start live monitoring
‚Ä¢ "Leave agent from my [meeting]" - Stop monitoring
‚Ä¢ "Get summary of my [meeting]" - AI-generated summary
‚Ä¢ "Analyze my [meeting]" - Chat analysis and insights

**üë• People Commands:**
‚Ä¢ "Find people named [name]"
‚Ä¢ "Show team members"
‚Ä¢ "Send message to [name]: [message]"
‚Ä¢ "Resolve users [name1, name2]"

**üïê Date/Time Formats I Understand:**
‚Ä¢ Relative: "today", "tomorrow", "next Monday", "next week"
‚Ä¢ Specific: "January 15", "2025-01-15", "Friday"
‚Ä¢ Times: "2pm", "14:30", "2:30pm", "10am", "3:00 PM"

**üí° Pro Tips:**
‚Ä¢ Use "latest" or "recent" to refer to your most recent meeting
‚Ä¢ I can understand natural language - just tell me what you need!
‚Ä¢ All meetings are created with auto-insights by default
‚Ä¢ I can resolve names to emails automatically
‚Ä¢ Date/time parsing is now much more accurate!

**üÜò Need more help?** Just ask me anything in natural language!`;

          addMessage(helpMsg, "bot");
          return;
        }

        // Status command
        if (lowerMessage === "status" || lowerMessage === "/status") {
          try {
            const response = await fetch(`${API_BASE_URL}/meetings/status`);
            const data = await response.json();

            const statusMsg = `üìä **Agent 365 System Status**

**üîß Core Services:**
‚Ä¢ Teams Integration: ${
              data.services.teams.available ? "üü¢ ACTIVE" : "üî¥ OFFLINE"
            }
‚Ä¢ AI Engine: ${data.services.ai.available ? "üü¢ ACTIVE" : "üî¥ OFFLINE"}
‚Ä¢ Auto-Insights: ${
              data.pocFeatures.realAiAgentJoin ? "üü¢ READY" : "üî¥ DISABLED"
            }
‚Ä¢ Enhanced Date/Time Parser: üü¢ ACTIVE

**üìà Available Features:**
‚Ä¢ Real Meeting Scheduling: ${
              data.pocFeatures.realMeetingScheduling ? "‚úÖ" : "‚ùå"
            }
‚Ä¢ User Resolution: ${data.pocFeatures.realUserResolution ? "‚úÖ" : "‚ùå"}
‚Ä¢ AI Agent Join: ${data.pocFeatures.realAiAgentJoin ? "‚úÖ" : "‚ùå"}
‚Ä¢ Chat Capture: ${data.pocFeatures.realChatCapture ? "‚úÖ" : "‚ùå"}
‚Ä¢ Summary Generation: ${data.pocFeatures.realSummaryGeneration ? "‚úÖ" : "‚ùå"}
‚Ä¢ Improved Date/Time Parsing: ‚úÖ

**üíæ Session Info:**
‚Ä¢ Session ID: ${sessionId}
‚Ä¢ Messages: ${conversationHistory.length}
‚Ä¢ Auto-Insights: ${autoInsightsActive ? "üü¢ Active" : "üî¥ Inactive"}

**üåê API Endpoint:** ${API_BASE_URL}`;

            addMessage(statusMsg, "bot");
            return;
          } catch (error) {
            addMessage(
              "‚ùå Could not retrieve system status. Please check connectivity.",
              "bot"
            );
            return;
          }
        }

        // Default to original handler
        return originalHandleUserMessage(message);
      };

      // Add version info
      console.log(`
ü§ñ Agent 365 - AI Meeting Assistant
üìÖ Version: 2.1.0 with Enhanced Date/Time Parsing
üîß Teams Integration: Active
üí° AI Engine: Gemini 2.0 Flash
üïê Date/Time Parser: Enhanced v2.1
üåê API: ${API_BASE_URL}
      `);
    </script>
  </body>
</html>